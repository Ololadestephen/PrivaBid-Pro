import { JsonRpcProvider, BrowserProvider, Contract, ethers, getAddress, isAddress } from 'ethers';
import { toBigIntBE, toBufferBE } from 'bigint-buffer';
import createHash from 'keccak';
import fetchRetry from 'fetch-retry';
import { threads } from 'wasm-feature-detect';

var global$1 = (typeof global !== "undefined" ? global :
  typeof self !== "undefined" ? self :
  typeof window !== "undefined" ? window : {});

/*
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Note: we use `wasm_bindgen_worker_`-prefixed message types to make sure
// we can handle bundling into other files, which might happen to have their
// own `postMessage`/`onmessage` communication channels.
//
// If we didn't take that into the account, we could send much simpler signals
// like just `0` or whatever, but the code would be less resilient.

function waitForMsgType(target, type) {
  return new Promise(resolve => {
    target.addEventListener('message', function onMsg({ data }) {
      if (data?.type !== type) return;
      target.removeEventListener('message', onMsg);
      resolve(data);
    });
  });
}

waitForMsgType(self, 'wasm_bindgen_worker_init').then(async ({ init, receiver }) => {
  // # Note 1
  // Our JS should have been generated in
  // `[out-dir]/snippets/wasm-bindgen-rayon-[hash]/workerHelpers.js`,
  // resolve the main module via `../../..`.
  //
  // This might need updating if the generated structure changes on wasm-bindgen
  // side ever in the future, but works well with bundlers today. The whole
  // point of this crate, after all, is to abstract away unstable features
  // and temporary bugs so that you don't need to deal with them in your code.
  //
  // # Note 2
  // This could be a regular import, but then some bundlers complain about
  // circular deps.
  //
  // Dynamic import could be cheap if this file was inlined into the parent,
  // which would require us just using `../../..` in `new Worker` below,
  // but that doesn't work because wasm-pack unconditionally adds
  // "sideEffects":false (see below).
  //
  // OTOH, even though it can't be inlined, it should be still reasonably
  // cheap since the requested file is already in cache (it was loaded by
  // the main thread).
  const pkg = await Promise.resolve().then(function () { return tfhe$1; });
  await pkg.default(init);
  postMessage({ type: 'wasm_bindgen_worker_ready' });
  pkg.wbg_rayon_start_worker(receiver);
});

async function startWorkers(module, memory, builder) {
  if (builder.numThreads() === 0) {
    throw new Error(`num_threads must be > 0.`);
  }

  const workerInit = {
    type: 'wasm_bindgen_worker_init',
    init: { module_or_path: module, memory },
    receiver: builder.receiver()
  };

  await Promise.all(
    Array.from({ length: builder.numThreads() }, async () => {
      // Self-spawn into a new Worker.
      //
      // TODO: while `new URL('...', import.meta.url) becomes a semi-standard
      // way to get asset URLs relative to the module across various bundlers
      // and browser, ideally we should switch to `import.meta.resolve`
      // once it becomes a standard.
      //
      // Note: we could use `../../..` as the URL here to inline workerHelpers.js
      // into the parent entry instead of creating another split point -
      // this would be preferable from optimization perspective -
      // however, Webpack then eliminates all message handler code
      // because wasm-pack produces "sideEffects":false in package.json
      // unconditionally.
      //
      // The only way to work around that is to have side effect code
      // in an entry point such as Worker file itself.
      const worker = new Worker(new URL('./workerHelpers.js', import.meta.url), {
        type: 'module'
      });
      worker.postMessage(workerInit);
      await waitForMsgType(worker, 'wasm_bindgen_worker_ready');
      return worker;
    })
  );
  builder.build();
}

let wasm$1;

function addToExternrefTable0$1(obj) {
    const idx = wasm$1.__externref_table_alloc();
    wasm$1.__wbindgen_export_2.set(idx, obj);
    return idx;
}

function handleError$1(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        const idx = addToExternrefTable0$1(e);
        wasm$1.__wbindgen_exn_store(idx);
    }
}

const cachedTextDecoder$1 = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder$1.decode(); }
let cachedUint8ArrayMemory0$1 = null;

function getUint8ArrayMemory0$1() {
    if (cachedUint8ArrayMemory0$1 === null || cachedUint8ArrayMemory0$1.buffer !== wasm$1.memory.buffer) {
        cachedUint8ArrayMemory0$1 = new Uint8Array(wasm$1.memory.buffer);
    }
    return cachedUint8ArrayMemory0$1;
}

function getStringFromWasm0$1(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder$1.decode(getUint8ArrayMemory0$1().slice(ptr, ptr + len));
}

let WASM_VECTOR_LEN$1 = 0;

const cachedTextEncoder$1 = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );

const encodeString$1 = function (arg, view) {
    const buf = cachedTextEncoder$1.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
};

function passStringToWasm0$1(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder$1.encode(arg);
        const ptr = malloc(buf.length, 1) >>> 0;
        getUint8ArrayMemory0$1().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN$1 = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;

    const mem = getUint8ArrayMemory0$1();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8ArrayMemory0$1().subarray(ptr + offset, ptr + len);
        const ret = encodeString$1(arg, view);

        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
    }

    WASM_VECTOR_LEN$1 = offset;
    return ptr;
}

let cachedDataViewMemory0$1 = null;

function getDataViewMemory0$1() {
    if (cachedDataViewMemory0$1 === null || cachedDataViewMemory0$1.buffer !== wasm$1.memory.buffer) {
        cachedDataViewMemory0$1 = new DataView(wasm$1.memory.buffer);
    }
    return cachedDataViewMemory0$1;
}

function isLikeNone$1(x) {
    return x === undefined || x === null;
}

function debugString$1(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString$1(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString$1(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches && builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}

function _assertClass$1(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
}

function takeFromExternrefTable0$1(idx) {
    const value = wasm$1.__wbindgen_export_2.get(idx);
    wasm$1.__externref_table_dealloc(idx);
    return value;
}

function getArrayU8FromWasm0$1(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8ArrayMemory0$1().subarray(ptr / 1, ptr / 1 + len);
}

function passArray8ToWasm0$1(arg, malloc) {
    const ptr = malloc(arg.length * 1, 1) >>> 0;
    getUint8ArrayMemory0$1().set(arg, ptr / 1);
    WASM_VECTOR_LEN$1 = arg.length;
    return ptr;
}

function init_panic_hook() {
    wasm$1.init_panic_hook();
}

/**
 * @param {TfheServerKey} server_key
 */
function set_server_key(server_key) {
    _assertClass$1(server_key, TfheServerKey);
    const ret = wasm$1.set_server_key(server_key.__wbg_ptr);
    if (ret[1]) {
        throw takeFromExternrefTable0$1(ret[0]);
    }
}

/**
 * @param {ShortintCompactPublicKeyEncryptionParametersName} param
 * @returns {string}
 */
function shortint_pke_params_name(param) {
    let deferred1_0;
    let deferred1_1;
    try {
        const ret = wasm$1.shortint_pke_params_name(param);
        deferred1_0 = ret[0];
        deferred1_1 = ret[1];
        return getStringFromWasm0$1(ret[0], ret[1]);
    } finally {
        wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
}

/**
 * @param {ShortintParametersName} param
 * @returns {string}
 */
function shortint_params_name(param) {
    let deferred1_0;
    let deferred1_1;
    try {
        const ret = wasm$1.shortint_params_name(param);
        deferred1_0 = ret[0];
        deferred1_1 = ret[1];
        return getStringFromWasm0$1(ret[0], ret[1]);
    } finally {
        wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
}

/**
 * @param {number} num_threads
 * @returns {Promise<any>}
 */
function initThreadPool(num_threads) {
    const ret = wasm$1.initThreadPool(num_threads);
    return ret;
}

/**
 * @param {number} receiver
 */
function wbg_rayon_start_worker(receiver) {
    wasm$1.wbg_rayon_start_worker(receiver);
}

/**
 * @enum {0 | 1}
 */
const BooleanEncryptionKeyChoice = Object.freeze({
    Big: 0, "0": "Big",
    Small: 1, "1": "Small",
});
/**
 * @enum {0 | 1 | 2 | 3}
 */
const BooleanParameterSet = Object.freeze({
    Default: 0, "0": "Default",
    TfheLib: 1, "1": "TfheLib",
    DefaultKsPbs: 2, "2": "DefaultKsPbs",
    TfheLibKsPbs: 3, "3": "TfheLibKsPbs",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30}
 */
const FheTypes = Object.freeze({
    Bool: 0, "0": "Bool",
    Uint2: 1, "1": "Uint2",
    Uint4: 2, "2": "Uint4",
    Uint6: 3, "3": "Uint6",
    Uint8: 4, "4": "Uint8",
    Uint10: 5, "5": "Uint10",
    Uint12: 6, "6": "Uint12",
    Uint14: 7, "7": "Uint14",
    Uint16: 8, "8": "Uint16",
    Uint32: 9, "9": "Uint32",
    Uint64: 10, "10": "Uint64",
    Uint128: 11, "11": "Uint128",
    Uint160: 12, "12": "Uint160",
    Uint256: 13, "13": "Uint256",
    Uint512: 14, "14": "Uint512",
    Uint1024: 15, "15": "Uint1024",
    Uint2048: 16, "16": "Uint2048",
    Int2: 17, "17": "Int2",
    Int4: 18, "18": "Int4",
    Int6: 19, "19": "Int6",
    Int8: 20, "20": "Int8",
    Int10: 21, "21": "Int10",
    Int12: 22, "22": "Int12",
    Int14: 23, "23": "Int14",
    Int16: 24, "24": "Int16",
    Int32: 25, "25": "Int32",
    Int64: 26, "26": "Int64",
    Int128: 27, "27": "Int128",
    Int160: 28, "28": "Int160",
    Int256: 29, "29": "Int256",
    AsciiString: 30, "30": "AsciiString",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4}
 */
const ShortintCompactPublicKeyEncryptionParametersName = Object.freeze({
    PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128: 0, "0": "PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128",
    V1_0_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128: 1, "1": "V1_0_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128",
    V1_0_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128_ZKV1: 2, "2": "V1_0_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128_ZKV1",
    V0_11_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M64: 3, "3": "V0_11_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M64",
    V0_11_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M64_ZKV1: 4, "4": "V0_11_PARAM_PKE_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M64_ZKV1",
});
/**
 * @enum {0 | 1}
 */
const ShortintEncryptionKeyChoice = Object.freeze({
    Big: 0, "0": "Big",
    Small: 1, "1": "Small",
});
/**
 * @enum {0 | 1}
 */
const ShortintPBSOrder = Object.freeze({
    KeyswitchBootstrap: 0, "0": "KeyswitchBootstrap",
    BootstrapKeyswitch: 1, "1": "BootstrapKeyswitch",
});
/**
 * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63 | 64 | 65 | 66 | 67 | 68 | 69 | 70 | 71 | 72 | 73 | 74 | 75 | 76 | 77 | 78 | 79 | 80 | 81 | 82 | 83 | 84 | 85 | 86 | 87 | 88 | 89 | 90 | 91 | 92 | 93 | 94 | 95 | 96 | 97 | 98 | 99 | 100 | 101 | 102 | 103 | 104 | 105 | 106 | 107 | 108 | 109 | 110 | 111 | 112 | 113 | 114 | 115 | 116 | 117 | 118 | 119 | 120 | 121 | 122 | 123 | 124 | 125 | 126 | 127 | 128 | 129 | 130 | 131 | 132 | 133 | 134 | 135 | 136 | 137 | 138 | 139 | 140 | 141 | 142 | 143}
 */
const ShortintParametersName = Object.freeze({
    PARAM_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128: 0, "0": "PARAM_MESSAGE_2_CARRY_2_KS_PBS_TUNIFORM_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_0_KS_PBS_GAUSSIAN_2M128: 1, "1": "V1_0_PARAM_MESSAGE_1_CARRY_0_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M128: 2, "2": "V1_0_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_2_CARRY_0_KS_PBS_GAUSSIAN_2M128: 3, "3": "V1_0_PARAM_MESSAGE_2_CARRY_0_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_2_KS_PBS_GAUSSIAN_2M128: 4, "4": "V1_0_PARAM_MESSAGE_1_CARRY_2_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_2_CARRY_1_KS_PBS_GAUSSIAN_2M128: 5, "5": "V1_0_PARAM_MESSAGE_2_CARRY_1_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_3_CARRY_0_KS_PBS_GAUSSIAN_2M128: 6, "6": "V1_0_PARAM_MESSAGE_3_CARRY_0_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_3_KS_PBS_GAUSSIAN_2M128: 7, "7": "V1_0_PARAM_MESSAGE_1_CARRY_3_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M128: 8, "8": "V1_0_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_3_CARRY_1_KS_PBS_GAUSSIAN_2M128: 9, "9": "V1_0_PARAM_MESSAGE_3_CARRY_1_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_4_CARRY_0_KS_PBS_GAUSSIAN_2M128: 10, "10": "V1_0_PARAM_MESSAGE_4_CARRY_0_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_4_KS_PBS_GAUSSIAN_2M128: 11, "11": "V1_0_PARAM_MESSAGE_1_CARRY_4_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_2_CARRY_3_KS_PBS_GAUSSIAN_2M128: 12, "12": "V1_0_PARAM_MESSAGE_2_CARRY_3_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_3_CARRY_2_KS_PBS_GAUSSIAN_2M128: 13, "13": "V1_0_PARAM_MESSAGE_3_CARRY_2_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_4_CARRY_1_KS_PBS_GAUSSIAN_2M128: 14, "14": "V1_0_PARAM_MESSAGE_4_CARRY_1_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_5_CARRY_0_KS_PBS_GAUSSIAN_2M128: 15, "15": "V1_0_PARAM_MESSAGE_5_CARRY_0_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_5_KS_PBS_GAUSSIAN_2M128: 16, "16": "V1_0_PARAM_MESSAGE_1_CARRY_5_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_2_CARRY_4_KS_PBS_GAUSSIAN_2M128: 17, "17": "V1_0_PARAM_MESSAGE_2_CARRY_4_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_3_CARRY_3_KS_PBS_GAUSSIAN_2M128: 18, "18": "V1_0_PARAM_MESSAGE_3_CARRY_3_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_4_CARRY_2_KS_PBS_GAUSSIAN_2M128: 19, "19": "V1_0_PARAM_MESSAGE_4_CARRY_2_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_5_CARRY_1_KS_PBS_GAUSSIAN_2M128: 20, "20": "V1_0_PARAM_MESSAGE_5_CARRY_1_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_6_CARRY_0_KS_PBS_GAUSSIAN_2M128: 21, "21": "V1_0_PARAM_MESSAGE_6_CARRY_0_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_6_KS_PBS_GAUSSIAN_2M128: 22, "22": "V1_0_PARAM_MESSAGE_1_CARRY_6_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_2_CARRY_5_KS_PBS_GAUSSIAN_2M128: 23, "23": "V1_0_PARAM_MESSAGE_2_CARRY_5_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_3_CARRY_4_KS_PBS_GAUSSIAN_2M128: 24, "24": "V1_0_PARAM_MESSAGE_3_CARRY_4_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_4_CARRY_3_KS_PBS_GAUSSIAN_2M128: 25, "25": "V1_0_PARAM_MESSAGE_4_CARRY_3_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_5_CARRY_2_KS_PBS_GAUSSIAN_2M128: 26, "26": "V1_0_PARAM_MESSAGE_5_CARRY_2_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_6_CARRY_1_KS_PBS_GAUSSIAN_2M128: 27, "27": "V1_0_PARAM_MESSAGE_6_CARRY_1_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_7_CARRY_0_KS_PBS_GAUSSIAN_2M128: 28, "28": "V1_0_PARAM_MESSAGE_7_CARRY_0_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_7_KS_PBS_GAUSSIAN_2M128: 29, "29": "V1_0_PARAM_MESSAGE_1_CARRY_7_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_2_CARRY_6_KS_PBS_GAUSSIAN_2M128: 30, "30": "V1_0_PARAM_MESSAGE_2_CARRY_6_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_3_CARRY_5_KS_PBS_GAUSSIAN_2M128: 31, "31": "V1_0_PARAM_MESSAGE_3_CARRY_5_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_4_CARRY_4_KS_PBS_GAUSSIAN_2M128: 32, "32": "V1_0_PARAM_MESSAGE_4_CARRY_4_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_5_CARRY_3_KS_PBS_GAUSSIAN_2M128: 33, "33": "V1_0_PARAM_MESSAGE_5_CARRY_3_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_6_CARRY_2_KS_PBS_GAUSSIAN_2M128: 34, "34": "V1_0_PARAM_MESSAGE_6_CARRY_2_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_7_CARRY_1_KS_PBS_GAUSSIAN_2M128: 35, "35": "V1_0_PARAM_MESSAGE_7_CARRY_1_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_8_CARRY_0_KS_PBS_GAUSSIAN_2M128: 36, "36": "V1_0_PARAM_MESSAGE_8_CARRY_0_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_1_PBS_KS_GAUSSIAN_2M128: 37, "37": "V1_0_PARAM_MESSAGE_1_CARRY_1_PBS_KS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_2_CARRY_2_PBS_KS_GAUSSIAN_2M128: 38, "38": "V1_0_PARAM_MESSAGE_2_CARRY_2_PBS_KS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_3_CARRY_3_PBS_KS_GAUSSIAN_2M128: 39, "39": "V1_0_PARAM_MESSAGE_3_CARRY_3_PBS_KS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_4_CARRY_4_PBS_KS_GAUSSIAN_2M128: 40, "40": "V1_0_PARAM_MESSAGE_4_CARRY_4_PBS_KS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 41, "41": "V1_0_PARAM_MESSAGE_1_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 42, "42": "V1_0_PARAM_MESSAGE_1_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 43, "43": "V1_0_PARAM_MESSAGE_1_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 44, "44": "V1_0_PARAM_MESSAGE_1_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 45, "45": "V1_0_PARAM_MESSAGE_1_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_7_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 46, "46": "V1_0_PARAM_MESSAGE_1_CARRY_7_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_2_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 47, "47": "V1_0_PARAM_MESSAGE_2_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 48, "48": "V1_0_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_2_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 49, "49": "V1_0_PARAM_MESSAGE_2_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_2_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 50, "50": "V1_0_PARAM_MESSAGE_2_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_2_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 51, "51": "V1_0_PARAM_MESSAGE_2_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_2_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 52, "52": "V1_0_PARAM_MESSAGE_2_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_3_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 53, "53": "V1_0_PARAM_MESSAGE_3_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_3_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 54, "54": "V1_0_PARAM_MESSAGE_3_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 55, "55": "V1_0_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_3_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 56, "56": "V1_0_PARAM_MESSAGE_3_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_3_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 57, "57": "V1_0_PARAM_MESSAGE_3_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_4_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 58, "58": "V1_0_PARAM_MESSAGE_4_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_4_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 59, "59": "V1_0_PARAM_MESSAGE_4_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_4_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 60, "60": "V1_0_PARAM_MESSAGE_4_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 61, "61": "V1_0_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_5_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 62, "62": "V1_0_PARAM_MESSAGE_5_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_5_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 63, "63": "V1_0_PARAM_MESSAGE_5_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_5_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 64, "64": "V1_0_PARAM_MESSAGE_5_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_6_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 65, "65": "V1_0_PARAM_MESSAGE_6_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_6_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 66, "66": "V1_0_PARAM_MESSAGE_6_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_7_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128: 67, "67": "V1_0_PARAM_MESSAGE_7_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 68, "68": "V1_0_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 69, "69": "V1_0_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 70, "70": "V1_0_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
    V1_0_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_PBS_KS_GAUSSIAN_2M128: 71, "71": "V1_0_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_PBS_KS_GAUSSIAN_2M128",
    V0_11_PARAM_MESSAGE_1_CARRY_0_KS_PBS_GAUSSIAN_2M64: 72, "72": "V0_11_PARAM_MESSAGE_1_CARRY_0_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M64: 73, "73": "V0_11_PARAM_MESSAGE_1_CARRY_1_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_2_CARRY_0_KS_PBS_GAUSSIAN_2M64: 74, "74": "V0_11_PARAM_MESSAGE_2_CARRY_0_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_2_KS_PBS_GAUSSIAN_2M64: 75, "75": "V0_11_PARAM_MESSAGE_1_CARRY_2_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_2_CARRY_1_KS_PBS_GAUSSIAN_2M64: 76, "76": "V0_11_PARAM_MESSAGE_2_CARRY_1_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_3_CARRY_0_KS_PBS_GAUSSIAN_2M64: 77, "77": "V0_11_PARAM_MESSAGE_3_CARRY_0_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_3_KS_PBS_GAUSSIAN_2M64: 78, "78": "V0_11_PARAM_MESSAGE_1_CARRY_3_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M64: 79, "79": "V0_11_PARAM_MESSAGE_2_CARRY_2_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_3_CARRY_1_KS_PBS_GAUSSIAN_2M64: 80, "80": "V0_11_PARAM_MESSAGE_3_CARRY_1_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_4_CARRY_0_KS_PBS_GAUSSIAN_2M64: 81, "81": "V0_11_PARAM_MESSAGE_4_CARRY_0_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_4_KS_PBS_GAUSSIAN_2M64: 82, "82": "V0_11_PARAM_MESSAGE_1_CARRY_4_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_2_CARRY_3_KS_PBS_GAUSSIAN_2M64: 83, "83": "V0_11_PARAM_MESSAGE_2_CARRY_3_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_3_CARRY_2_KS_PBS_GAUSSIAN_2M64: 84, "84": "V0_11_PARAM_MESSAGE_3_CARRY_2_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_4_CARRY_1_KS_PBS_GAUSSIAN_2M64: 85, "85": "V0_11_PARAM_MESSAGE_4_CARRY_1_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_5_CARRY_0_KS_PBS_GAUSSIAN_2M64: 86, "86": "V0_11_PARAM_MESSAGE_5_CARRY_0_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_5_KS_PBS_GAUSSIAN_2M64: 87, "87": "V0_11_PARAM_MESSAGE_1_CARRY_5_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_2_CARRY_4_KS_PBS_GAUSSIAN_2M64: 88, "88": "V0_11_PARAM_MESSAGE_2_CARRY_4_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_3_CARRY_3_KS_PBS_GAUSSIAN_2M64: 89, "89": "V0_11_PARAM_MESSAGE_3_CARRY_3_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_4_CARRY_2_KS_PBS_GAUSSIAN_2M64: 90, "90": "V0_11_PARAM_MESSAGE_4_CARRY_2_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_5_CARRY_1_KS_PBS_GAUSSIAN_2M64: 91, "91": "V0_11_PARAM_MESSAGE_5_CARRY_1_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_6_CARRY_0_KS_PBS_GAUSSIAN_2M64: 92, "92": "V0_11_PARAM_MESSAGE_6_CARRY_0_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_6_KS_PBS_GAUSSIAN_2M64: 93, "93": "V0_11_PARAM_MESSAGE_1_CARRY_6_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_2_CARRY_5_KS_PBS_GAUSSIAN_2M64: 94, "94": "V0_11_PARAM_MESSAGE_2_CARRY_5_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_3_CARRY_4_KS_PBS_GAUSSIAN_2M64: 95, "95": "V0_11_PARAM_MESSAGE_3_CARRY_4_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_4_CARRY_3_KS_PBS_GAUSSIAN_2M64: 96, "96": "V0_11_PARAM_MESSAGE_4_CARRY_3_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_5_CARRY_2_KS_PBS_GAUSSIAN_2M64: 97, "97": "V0_11_PARAM_MESSAGE_5_CARRY_2_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_6_CARRY_1_KS_PBS_GAUSSIAN_2M64: 98, "98": "V0_11_PARAM_MESSAGE_6_CARRY_1_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_7_CARRY_0_KS_PBS_GAUSSIAN_2M64: 99, "99": "V0_11_PARAM_MESSAGE_7_CARRY_0_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_7_KS_PBS_GAUSSIAN_2M64: 100, "100": "V0_11_PARAM_MESSAGE_1_CARRY_7_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_2_CARRY_6_KS_PBS_GAUSSIAN_2M64: 101, "101": "V0_11_PARAM_MESSAGE_2_CARRY_6_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_3_CARRY_5_KS_PBS_GAUSSIAN_2M64: 102, "102": "V0_11_PARAM_MESSAGE_3_CARRY_5_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_4_CARRY_4_KS_PBS_GAUSSIAN_2M64: 103, "103": "V0_11_PARAM_MESSAGE_4_CARRY_4_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_5_CARRY_3_KS_PBS_GAUSSIAN_2M64: 104, "104": "V0_11_PARAM_MESSAGE_5_CARRY_3_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_6_CARRY_2_KS_PBS_GAUSSIAN_2M64: 105, "105": "V0_11_PARAM_MESSAGE_6_CARRY_2_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_7_CARRY_1_KS_PBS_GAUSSIAN_2M64: 106, "106": "V0_11_PARAM_MESSAGE_7_CARRY_1_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_8_CARRY_0_KS_PBS_GAUSSIAN_2M64: 107, "107": "V0_11_PARAM_MESSAGE_8_CARRY_0_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_1_PBS_KS_GAUSSIAN_2M64: 108, "108": "V0_11_PARAM_MESSAGE_1_CARRY_1_PBS_KS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_2_CARRY_2_PBS_KS_GAUSSIAN_2M64: 109, "109": "V0_11_PARAM_MESSAGE_2_CARRY_2_PBS_KS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_3_CARRY_3_PBS_KS_GAUSSIAN_2M64: 110, "110": "V0_11_PARAM_MESSAGE_3_CARRY_3_PBS_KS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_4_CARRY_4_PBS_KS_GAUSSIAN_2M64: 111, "111": "V0_11_PARAM_MESSAGE_4_CARRY_4_PBS_KS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 112, "112": "V0_11_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 113, "113": "V0_11_PARAM_MESSAGE_1_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 114, "114": "V0_11_PARAM_MESSAGE_1_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 115, "115": "V0_11_PARAM_MESSAGE_1_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 116, "116": "V0_11_PARAM_MESSAGE_1_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 117, "117": "V0_11_PARAM_MESSAGE_1_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_7_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 118, "118": "V0_11_PARAM_MESSAGE_1_CARRY_7_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_2_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 119, "119": "V0_11_PARAM_MESSAGE_2_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 120, "120": "V0_11_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_2_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 121, "121": "V0_11_PARAM_MESSAGE_2_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_2_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 122, "122": "V0_11_PARAM_MESSAGE_2_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_2_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 123, "123": "V0_11_PARAM_MESSAGE_2_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_2_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 124, "124": "V0_11_PARAM_MESSAGE_2_CARRY_6_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_3_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 125, "125": "V0_11_PARAM_MESSAGE_3_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_3_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 126, "126": "V0_11_PARAM_MESSAGE_3_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 127, "127": "V0_11_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_3_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 128, "128": "V0_11_PARAM_MESSAGE_3_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_3_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 129, "129": "V0_11_PARAM_MESSAGE_3_CARRY_5_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_4_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 130, "130": "V0_11_PARAM_MESSAGE_4_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_4_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 131, "131": "V0_11_PARAM_MESSAGE_4_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_4_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 132, "132": "V0_11_PARAM_MESSAGE_4_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 133, "133": "V0_11_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_5_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 134, "134": "V0_11_PARAM_MESSAGE_5_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_5_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 135, "135": "V0_11_PARAM_MESSAGE_5_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_5_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 136, "136": "V0_11_PARAM_MESSAGE_5_CARRY_3_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_6_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 137, "137": "V0_11_PARAM_MESSAGE_6_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_6_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 138, "138": "V0_11_PARAM_MESSAGE_6_CARRY_2_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_7_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64: 139, "139": "V0_11_PARAM_MESSAGE_7_CARRY_1_COMPACT_PK_KS_PBS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_PBS_KS_GAUSSIAN_2M64: 140, "140": "V0_11_PARAM_MESSAGE_1_CARRY_1_COMPACT_PK_PBS_KS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_PBS_KS_GAUSSIAN_2M64: 141, "141": "V0_11_PARAM_MESSAGE_2_CARRY_2_COMPACT_PK_PBS_KS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_PBS_KS_GAUSSIAN_2M64: 142, "142": "V0_11_PARAM_MESSAGE_3_CARRY_3_COMPACT_PK_PBS_KS_GAUSSIAN_2M64",
    V0_11_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_PBS_KS_GAUSSIAN_2M64: 143, "143": "V0_11_PARAM_MESSAGE_4_CARRY_4_COMPACT_PK_PBS_KS_GAUSSIAN_2M64",
});
/**
 * @enum {0 | 1}
 */
const ZkComputeLoad = Object.freeze({
    Proof: 0, "0": "Proof",
    Verify: 1, "1": "Verify",
});

const BooleanFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_boolean_free(ptr >>> 0, 1));

class Boolean {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BooleanFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_boolean_free(ptr, 0);
    }
    /**
     * @param {number} parameter_choice
     * @returns {BooleanParameters}
     */
    static get_parameters(parameter_choice) {
        const ret = wasm$1.boolean_get_parameters(parameter_choice);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return BooleanParameters.__wrap(ret[0]);
    }
    /**
     * @param {number} std_dev
     * @returns {BooleanNoiseDistribution}
     */
    static new_gaussian_from_std_dev(std_dev) {
        const ret = wasm$1.boolean_new_gaussian_from_std_dev(std_dev);
        return BooleanNoiseDistribution.__wrap(ret);
    }
    /**
     * @param {number} bound_log2
     * @returns {BooleanNoiseDistribution}
     */
    static try_new_t_uniform(bound_log2) {
        const ret = wasm$1.boolean_try_new_t_uniform(bound_log2);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return BooleanNoiseDistribution.__wrap(ret[0]);
    }
    /**
     * @param {number} lwe_dimension
     * @param {number} glwe_dimension
     * @param {number} polynomial_size
     * @param {BooleanNoiseDistribution} lwe_noise_distribution
     * @param {BooleanNoiseDistribution} glwe_noise_distribution
     * @param {number} pbs_base_log
     * @param {number} pbs_level
     * @param {number} ks_base_log
     * @param {number} ks_level
     * @param {BooleanEncryptionKeyChoice} encryption_key_choice
     * @returns {BooleanParameters}
     */
    static new_parameters(lwe_dimension, glwe_dimension, polynomial_size, lwe_noise_distribution, glwe_noise_distribution, pbs_base_log, pbs_level, ks_base_log, ks_level, encryption_key_choice) {
        _assertClass$1(lwe_noise_distribution, BooleanNoiseDistribution);
        _assertClass$1(glwe_noise_distribution, BooleanNoiseDistribution);
        const ret = wasm$1.boolean_new_parameters(lwe_dimension, glwe_dimension, polynomial_size, lwe_noise_distribution.__wbg_ptr, glwe_noise_distribution.__wbg_ptr, pbs_base_log, pbs_level, ks_base_log, ks_level, encryption_key_choice);
        return BooleanParameters.__wrap(ret);
    }
    /**
     * @param {bigint} seed_high_bytes
     * @param {bigint} seed_low_bytes
     * @param {BooleanParameters} parameters
     * @returns {BooleanClientKey}
     */
    static new_client_key_from_seed_and_parameters(seed_high_bytes, seed_low_bytes, parameters) {
        _assertClass$1(parameters, BooleanParameters);
        const ret = wasm$1.boolean_new_client_key_from_seed_and_parameters(seed_high_bytes, seed_low_bytes, parameters.__wbg_ptr);
        return BooleanClientKey.__wrap(ret);
    }
    /**
     * @param {BooleanParameters} parameters
     * @returns {BooleanClientKey}
     */
    static new_client_key(parameters) {
        _assertClass$1(parameters, BooleanParameters);
        const ret = wasm$1.boolean_new_client_key(parameters.__wbg_ptr);
        return BooleanClientKey.__wrap(ret);
    }
    /**
     * @param {BooleanClientKey} client_key
     * @returns {BooleanPublicKey}
     */
    static new_public_key(client_key) {
        _assertClass$1(client_key, BooleanClientKey);
        const ret = wasm$1.boolean_new_public_key(client_key.__wbg_ptr);
        return BooleanPublicKey.__wrap(ret);
    }
    /**
     * @param {BooleanClientKey} client_key
     * @returns {BooleanCompressedServerKey}
     */
    static new_compressed_server_key(client_key) {
        _assertClass$1(client_key, BooleanClientKey);
        const ret = wasm$1.boolean_new_compressed_server_key(client_key.__wbg_ptr);
        return BooleanCompressedServerKey.__wrap(ret);
    }
    /**
     * @param {BooleanClientKey} client_key
     * @param {boolean} message
     * @returns {BooleanCiphertext}
     */
    static encrypt(client_key, message) {
        _assertClass$1(client_key, BooleanClientKey);
        const ret = wasm$1.boolean_encrypt(client_key.__wbg_ptr, message);
        return BooleanCiphertext.__wrap(ret);
    }
    /**
     * @param {BooleanClientKey} client_key
     * @param {boolean} message
     * @returns {BooleanCompressedCiphertext}
     */
    static encrypt_compressed(client_key, message) {
        _assertClass$1(client_key, BooleanClientKey);
        const ret = wasm$1.boolean_encrypt_compressed(client_key.__wbg_ptr, message);
        return BooleanCompressedCiphertext.__wrap(ret);
    }
    /**
     * @param {BooleanCompressedCiphertext} compressed_ciphertext
     * @returns {BooleanCiphertext}
     */
    static decompress_ciphertext(compressed_ciphertext) {
        _assertClass$1(compressed_ciphertext, BooleanCompressedCiphertext);
        const ret = wasm$1.boolean_decompress_ciphertext(compressed_ciphertext.__wbg_ptr);
        return BooleanCiphertext.__wrap(ret);
    }
    /**
     * @param {BooleanPublicKey} public_key
     * @param {boolean} message
     * @returns {BooleanCiphertext}
     */
    static encrypt_with_public_key(public_key, message) {
        _assertClass$1(public_key, BooleanPublicKey);
        const ret = wasm$1.boolean_encrypt_with_public_key(public_key.__wbg_ptr, message);
        return BooleanCiphertext.__wrap(ret);
    }
    /**
     * @param {boolean} message
     * @returns {BooleanCiphertext}
     */
    static trivial_encrypt(message) {
        const ret = wasm$1.boolean_trivial_encrypt(message);
        return BooleanCiphertext.__wrap(ret);
    }
    /**
     * @param {BooleanClientKey} client_key
     * @param {BooleanCiphertext} ct
     * @returns {boolean}
     */
    static decrypt(client_key, ct) {
        _assertClass$1(client_key, BooleanClientKey);
        _assertClass$1(ct, BooleanCiphertext);
        const ret = wasm$1.boolean_decrypt(client_key.__wbg_ptr, ct.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {BooleanCiphertext} ciphertext
     * @returns {Uint8Array}
     */
    static serialize_ciphertext(ciphertext) {
        _assertClass$1(ciphertext, BooleanCiphertext);
        const ret = wasm$1.boolean_serialize_ciphertext(ciphertext.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {BooleanCiphertext}
     */
    static deserialize_ciphertext(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.boolean_deserialize_ciphertext(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return BooleanCiphertext.__wrap(ret[0]);
    }
    /**
     * @param {BooleanCompressedCiphertext} ciphertext
     * @returns {Uint8Array}
     */
    static serialize_compressed_ciphertext(ciphertext) {
        _assertClass$1(ciphertext, BooleanCompressedCiphertext);
        const ret = wasm$1.boolean_serialize_compressed_ciphertext(ciphertext.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {BooleanCompressedCiphertext}
     */
    static deserialize_compressed_ciphertext(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.boolean_deserialize_compressed_ciphertext(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return BooleanCompressedCiphertext.__wrap(ret[0]);
    }
    /**
     * @param {BooleanClientKey} client_key
     * @returns {Uint8Array}
     */
    static serialize_client_key(client_key) {
        _assertClass$1(client_key, BooleanClientKey);
        const ret = wasm$1.boolean_serialize_client_key(client_key.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {BooleanClientKey}
     */
    static deserialize_client_key(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.boolean_deserialize_client_key(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return BooleanClientKey.__wrap(ret[0]);
    }
    /**
     * @param {BooleanPublicKey} public_key
     * @returns {Uint8Array}
     */
    static serialize_public_key(public_key) {
        _assertClass$1(public_key, BooleanPublicKey);
        const ret = wasm$1.boolean_serialize_public_key(public_key.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {BooleanPublicKey}
     */
    static deserialize_public_key(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.boolean_deserialize_public_key(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return BooleanPublicKey.__wrap(ret[0]);
    }
    /**
     * @param {BooleanCompressedServerKey} server_key
     * @returns {Uint8Array}
     */
    static serialize_compressed_server_key(server_key) {
        _assertClass$1(server_key, BooleanCompressedServerKey);
        const ret = wasm$1.boolean_serialize_compressed_server_key(server_key.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {BooleanCompressedServerKey}
     */
    static deserialize_compressed_server_key(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.boolean_deserialize_compressed_server_key(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return BooleanCompressedServerKey.__wrap(ret[0]);
    }
}

const BooleanCiphertextFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_booleanciphertext_free(ptr >>> 0, 1));

class BooleanCiphertext {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BooleanCiphertext.prototype);
        obj.__wbg_ptr = ptr;
        BooleanCiphertextFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BooleanCiphertextFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_booleanciphertext_free(ptr, 0);
    }
}

const BooleanClientKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_booleanclientkey_free(ptr >>> 0, 1));

class BooleanClientKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BooleanClientKey.prototype);
        obj.__wbg_ptr = ptr;
        BooleanClientKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BooleanClientKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_booleanclientkey_free(ptr, 0);
    }
}

const BooleanCompressedCiphertextFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_booleancompressedciphertext_free(ptr >>> 0, 1));

class BooleanCompressedCiphertext {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BooleanCompressedCiphertext.prototype);
        obj.__wbg_ptr = ptr;
        BooleanCompressedCiphertextFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BooleanCompressedCiphertextFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_booleancompressedciphertext_free(ptr, 0);
    }
}

const BooleanCompressedServerKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_booleancompressedserverkey_free(ptr >>> 0, 1));

class BooleanCompressedServerKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BooleanCompressedServerKey.prototype);
        obj.__wbg_ptr = ptr;
        BooleanCompressedServerKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BooleanCompressedServerKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_booleancompressedserverkey_free(ptr, 0);
    }
}

const BooleanNoiseDistributionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_booleannoisedistribution_free(ptr >>> 0, 1));

class BooleanNoiseDistribution {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BooleanNoiseDistribution.prototype);
        obj.__wbg_ptr = ptr;
        BooleanNoiseDistributionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BooleanNoiseDistributionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_booleannoisedistribution_free(ptr, 0);
    }
}

const BooleanParametersFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_booleanparameters_free(ptr >>> 0, 1));

class BooleanParameters {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BooleanParameters.prototype);
        obj.__wbg_ptr = ptr;
        BooleanParametersFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BooleanParametersFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_booleanparameters_free(ptr, 0);
    }
}

const BooleanPublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_booleanpublickey_free(ptr >>> 0, 1));

class BooleanPublicKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(BooleanPublicKey.prototype);
        obj.__wbg_ptr = ptr;
        BooleanPublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        BooleanPublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_booleanpublickey_free(ptr, 0);
    }
}

const CompactCiphertextListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compactciphertextlist_free(ptr >>> 0, 1));

class CompactCiphertextList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompactCiphertextList.prototype);
        obj.__wbg_ptr = ptr;
        CompactCiphertextListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompactCiphertextListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compactciphertextlist_free(ptr, 0);
    }
    /**
     * @param {TfheCompactPublicKey} public_key
     * @returns {CompactCiphertextListBuilder}
     */
    static builder(public_key) {
        _assertClass$1(public_key, TfheCompactPublicKey);
        const ret = wasm$1.compactciphertextlist_builder(public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompactCiphertextListBuilder.__wrap(ret[0]);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm$1.compactciphertextlist_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {boolean}
     */
    is_empty() {
        const ret = wasm$1.compactciphertextlist_is_empty(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {number} index
     * @returns {FheTypes | undefined}
     */
    get_kind_of(index) {
        const ret = wasm$1.compactciphertextlist_get_kind_of(this.__wbg_ptr, index);
        return ret === 31 ? undefined : ret;
    }
    /**
     * @returns {CompactCiphertextListExpander}
     */
    expand() {
        const ret = wasm$1.compactciphertextlist_expand(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompactCiphertextListExpander.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compactciphertextlist_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompactCiphertextList}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compactciphertextlist_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompactCiphertextList.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compactciphertextlist_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompactCiphertextList}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compactciphertextlist_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompactCiphertextList.__wrap(ret[0]);
    }
}

const CompactCiphertextListBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compactciphertextlistbuilder_free(ptr >>> 0, 1));

class CompactCiphertextListBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompactCiphertextListBuilder.prototype);
        obj.__wbg_ptr = ptr;
        CompactCiphertextListBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompactCiphertextListBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compactciphertextlistbuilder_free(ptr, 0);
    }
    /**
     * @param {number} value
     */
    push_u2(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u2(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_u4(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u4(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_u6(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u6(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_u8(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u8(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_u10(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u10(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_u12(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u12(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_u14(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u14(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_u16(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u16(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_u32(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u32(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {bigint} value
     */
    push_u64(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u64(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_i2(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_i2(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_i4(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_i4(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_i6(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_i6(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_i8(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_i8(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_i10(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_i10(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_i12(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_i12(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_i14(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_i14(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_i16(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_i16(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {number} value
     */
    push_i32(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_i32(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {bigint} value
     */
    push_i64(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_i64(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {any} value
     */
    push_u128(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u128(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {any} value
     */
    push_u160(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u160(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {any} value
     */
    push_u256(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u256(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {any} value
     */
    push_u512(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u512(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {any} value
     */
    push_u1024(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u1024(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {any} value
     */
    push_u2048(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_u2048(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {any} value
     */
    push_i128(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_i128(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {any} value
     */
    push_i160(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_i160(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {any} value
     */
    push_i256(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_i256(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @param {boolean} value
     */
    push_boolean(value) {
        const ret = wasm$1.compactciphertextlistbuilder_push_boolean(this.__wbg_ptr, value);
        if (ret[1]) {
            throw takeFromExternrefTable0$1(ret[0]);
        }
    }
    /**
     * @returns {CompactCiphertextList}
     */
    build() {
        const ret = wasm$1.compactciphertextlistbuilder_build(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompactCiphertextList.__wrap(ret[0]);
    }
    /**
     * @returns {CompactCiphertextList}
     */
    build_packed() {
        const ret = wasm$1.compactciphertextlistbuilder_build_packed(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompactCiphertextList.__wrap(ret[0]);
    }
    /**
     * @param {CompactPkeCrs} crs
     * @param {Uint8Array} metadata
     * @param {ZkComputeLoad} compute_load
     * @returns {ProvenCompactCiphertextList}
     */
    build_with_proof_packed(crs, metadata, compute_load) {
        _assertClass$1(crs, CompactPkeCrs);
        const ptr0 = passArray8ToWasm0$1(metadata, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compactciphertextlistbuilder_build_with_proof_packed(this.__wbg_ptr, crs.__wbg_ptr, ptr0, len0, compute_load);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ProvenCompactCiphertextList.__wrap(ret[0]);
    }
}

const CompactCiphertextListExpanderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compactciphertextlistexpander_free(ptr >>> 0, 1));

class CompactCiphertextListExpander {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompactCiphertextListExpander.prototype);
        obj.__wbg_ptr = ptr;
        CompactCiphertextListExpanderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompactCiphertextListExpanderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compactciphertextlistexpander_free(ptr, 0);
    }
    /**
     * @param {number} index
     * @returns {FheUint2}
     */
    get_uint2(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint2(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint2.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheUint4}
     */
    get_uint4(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint4(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint4.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheUint6}
     */
    get_uint6(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint6(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint6.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheUint8}
     */
    get_uint8(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint8(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint8.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheUint10}
     */
    get_uint10(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint10(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint10.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheUint12}
     */
    get_uint12(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint12(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint12.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheUint14}
     */
    get_uint14(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint14(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint14.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheUint16}
     */
    get_uint16(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint16(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint16.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheUint32}
     */
    get_uint32(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint32(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint32.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheUint64}
     */
    get_uint64(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint64(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint64.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheUint128}
     */
    get_uint128(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint128(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint128.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheUint160}
     */
    get_uint160(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint160(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint160.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheUint256}
     */
    get_uint256(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint256(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint256.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheUint512}
     */
    get_uint512(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint512(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint512.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheUint1024}
     */
    get_uint1024(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint1024(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint1024.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheUint2048}
     */
    get_uint2048(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_uint2048(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint2048.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheInt2}
     */
    get_int2(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_int2(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt2.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheInt4}
     */
    get_int4(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_int4(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt4.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheInt6}
     */
    get_int6(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_int6(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt6.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheInt8}
     */
    get_int8(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_int8(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt8.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheInt10}
     */
    get_int10(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_int10(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt10.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheInt12}
     */
    get_int12(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_int12(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt12.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheInt14}
     */
    get_int14(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_int14(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt14.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheInt16}
     */
    get_int16(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_int16(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt16.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheInt32}
     */
    get_int32(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_int32(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt32.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheInt64}
     */
    get_int64(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_int64(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt64.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheInt128}
     */
    get_int128(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_int128(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt128.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheInt160}
     */
    get_int160(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_int160(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt160.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheInt256}
     */
    get_int256(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_int256(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt256.__wrap(ret[0]);
    }
    /**
     * @param {number} index
     * @returns {FheBool}
     */
    get_bool(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_bool(this.__wbg_ptr, index);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheBool.__wrap(ret[0]);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm$1.compactciphertextlistexpander_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {boolean}
     */
    is_empty() {
        const ret = wasm$1.compactciphertextlistexpander_is_empty(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {number} index
     * @returns {FheTypes | undefined}
     */
    get_kind_of(index) {
        const ret = wasm$1.compactciphertextlistexpander_get_kind_of(this.__wbg_ptr, index);
        return ret === 31 ? undefined : ret;
    }
}

const CompactPkeCrsFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compactpkecrs_free(ptr >>> 0, 1));

class CompactPkeCrs {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompactPkeCrs.prototype);
        obj.__wbg_ptr = ptr;
        CompactPkeCrsFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompactPkeCrsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compactpkecrs_free(ptr, 0);
    }
    /**
     * @param {boolean} compress
     * @returns {Uint8Array}
     */
    serialize(compress) {
        const ret = wasm$1.compactpkecrs_serialize(this.__wbg_ptr, compress);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompactPkeCrs}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compactpkecrs_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompactPkeCrs.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compactpkecrs_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompactPkeCrs}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compactpkecrs_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompactPkeCrs.__wrap(ret[0]);
    }
    /**
     * @param {TfheConfig} config
     * @param {number} max_num_bits
     * @returns {CompactPkeCrs}
     */
    static from_config(config, max_num_bits) {
        _assertClass$1(config, TfheConfig);
        const ret = wasm$1.compactpkecrs_from_config(config.__wbg_ptr, max_num_bits);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompactPkeCrs.__wrap(ret[0]);
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompactPkeCrs}
     */
    static deserialize_from_public_params(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compactpkecrs_deserialize_from_public_params(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompactPkeCrs.__wrap(ret[0]);
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompactPkeCrs}
     */
    static safe_deserialize_from_public_params(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compactpkecrs_safe_deserialize_from_public_params(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompactPkeCrs.__wrap(ret[0]);
    }
}

const CompressedFheBoolFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfhebool_free(ptr >>> 0, 1));

class CompressedFheBool {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheBool.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheBoolFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheBoolFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfhebool_free(ptr, 0);
    }
    /**
     * @param {boolean} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheBool}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfhebool_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheBool.__wrap(ret[0]);
    }
    /**
     * @returns {FheBool}
     */
    decompress() {
        const ret = wasm$1.compressedfhebool_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheBool.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfhebool_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheBool}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfhebool_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheBool.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfhebool_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheBool}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfhebool_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheBool.__wrap(ret[0]);
    }
}

const CompressedFheInt10Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint10_free(ptr >>> 0, 1));

class CompressedFheInt10 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheInt10.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheInt10Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheInt10Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheint10_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheInt10}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheint10_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt10.__wrap(ret[0]);
    }
    /**
     * @returns {FheInt10}
     */
    decompress() {
        const ret = wasm$1.compressedfheint10_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt10.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheint10_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheInt10}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint10_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt10.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheint10_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheInt10}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint10_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt10.__wrap(ret[0]);
    }
}

const CompressedFheInt12Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint12_free(ptr >>> 0, 1));

class CompressedFheInt12 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheInt12.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheInt12Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheInt12Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheint12_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheInt12}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheint12_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt12.__wrap(ret[0]);
    }
    /**
     * @returns {FheInt12}
     */
    decompress() {
        const ret = wasm$1.compressedfheint12_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt12.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheint12_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheInt12}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint12_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt12.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheint12_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheInt12}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint12_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt12.__wrap(ret[0]);
    }
}

const CompressedFheInt128Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint128_free(ptr >>> 0, 1));

class CompressedFheInt128 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheInt128.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheInt128Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheInt128Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheint128_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheInt128}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheint128_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt128.__wrap(ret[0]);
    }
    /**
     * @returns {FheInt128}
     */
    decompress() {
        const ret = wasm$1.compressedfheint128_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt128.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheint128_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheInt128}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint128_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt128.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheint128_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheInt128}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint128_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt128.__wrap(ret[0]);
    }
}

const CompressedFheInt14Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint14_free(ptr >>> 0, 1));

class CompressedFheInt14 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheInt14.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheInt14Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheInt14Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheint14_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheInt14}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheint14_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt14.__wrap(ret[0]);
    }
    /**
     * @returns {FheInt14}
     */
    decompress() {
        const ret = wasm$1.compressedfheint14_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt14.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheint14_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheInt14}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint14_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt14.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheint14_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheInt14}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint14_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt14.__wrap(ret[0]);
    }
}

const CompressedFheInt16Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint16_free(ptr >>> 0, 1));

class CompressedFheInt16 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheInt16.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheInt16Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheInt16Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheint16_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheInt16}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheint16_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt16.__wrap(ret[0]);
    }
    /**
     * @returns {FheInt16}
     */
    decompress() {
        const ret = wasm$1.compressedfheint16_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt16.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheint16_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheInt16}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint16_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt16.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheint16_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheInt16}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint16_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt16.__wrap(ret[0]);
    }
}

const CompressedFheInt160Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint160_free(ptr >>> 0, 1));

class CompressedFheInt160 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheInt160.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheInt160Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheInt160Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheint160_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheInt160}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheint160_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt160.__wrap(ret[0]);
    }
    /**
     * @returns {FheInt160}
     */
    decompress() {
        const ret = wasm$1.compressedfheint160_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt160.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheint160_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheInt160}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint160_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt160.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheint160_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheInt160}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint160_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt160.__wrap(ret[0]);
    }
}

const CompressedFheInt2Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint2_free(ptr >>> 0, 1));

class CompressedFheInt2 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheInt2.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheInt2Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheInt2Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheint2_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheInt2}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheint2_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt2.__wrap(ret[0]);
    }
    /**
     * @returns {FheInt2}
     */
    decompress() {
        const ret = wasm$1.compressedfheint2_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt2.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheint2_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheInt2}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint2_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt2.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheint2_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheInt2}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint2_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt2.__wrap(ret[0]);
    }
}

const CompressedFheInt256Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint256_free(ptr >>> 0, 1));

class CompressedFheInt256 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheInt256.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheInt256Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheInt256Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheint256_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheInt256}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheint256_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt256.__wrap(ret[0]);
    }
    /**
     * @returns {FheInt256}
     */
    decompress() {
        const ret = wasm$1.compressedfheint256_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt256.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheint256_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheInt256}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint256_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt256.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheint256_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheInt256}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint256_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt256.__wrap(ret[0]);
    }
}

const CompressedFheInt32Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint32_free(ptr >>> 0, 1));

class CompressedFheInt32 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheInt32.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheInt32Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheInt32Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheint32_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheInt32}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheint32_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt32.__wrap(ret[0]);
    }
    /**
     * @returns {FheInt32}
     */
    decompress() {
        const ret = wasm$1.compressedfheint32_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt32.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheint32_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheInt32}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint32_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt32.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheint32_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheInt32}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint32_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt32.__wrap(ret[0]);
    }
}

const CompressedFheInt4Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint4_free(ptr >>> 0, 1));

class CompressedFheInt4 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheInt4.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheInt4Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheInt4Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheint4_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheInt4}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheint4_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt4.__wrap(ret[0]);
    }
    /**
     * @returns {FheInt4}
     */
    decompress() {
        const ret = wasm$1.compressedfheint4_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt4.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheint4_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheInt4}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint4_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt4.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheint4_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheInt4}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint4_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt4.__wrap(ret[0]);
    }
}

const CompressedFheInt6Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint6_free(ptr >>> 0, 1));

class CompressedFheInt6 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheInt6.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheInt6Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheInt6Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheint6_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheInt6}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheint6_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt6.__wrap(ret[0]);
    }
    /**
     * @returns {FheInt6}
     */
    decompress() {
        const ret = wasm$1.compressedfheint6_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt6.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheint6_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheInt6}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint6_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt6.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheint6_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheInt6}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint6_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt6.__wrap(ret[0]);
    }
}

const CompressedFheInt64Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint64_free(ptr >>> 0, 1));

class CompressedFheInt64 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheInt64.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheInt64Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheInt64Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheint64_free(ptr, 0);
    }
    /**
     * @param {bigint} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheInt64}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheint64_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt64.__wrap(ret[0]);
    }
    /**
     * @returns {FheInt64}
     */
    decompress() {
        const ret = wasm$1.compressedfheint64_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt64.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheint64_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheInt64}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint64_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt64.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheint64_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheInt64}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint64_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt64.__wrap(ret[0]);
    }
}

const CompressedFheInt8Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheint8_free(ptr >>> 0, 1));

class CompressedFheInt8 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheInt8.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheInt8Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheInt8Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheint8_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheInt8}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheint8_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt8.__wrap(ret[0]);
    }
    /**
     * @returns {FheInt8}
     */
    decompress() {
        const ret = wasm$1.compressedfheint8_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt8.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheint8_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheInt8}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint8_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt8.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheint8_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheInt8}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheint8_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheInt8.__wrap(ret[0]);
    }
}

const CompressedFheUint10Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint10_free(ptr >>> 0, 1));

class CompressedFheUint10 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint10.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint10Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint10Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint10_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint10}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint10_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint10.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint10}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint10_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint10.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint10_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint10}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint10_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint10.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint10_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint10}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint10_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint10.__wrap(ret[0]);
    }
}

const CompressedFheUint1024Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint1024_free(ptr >>> 0, 1));

class CompressedFheUint1024 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint1024.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint1024Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint1024Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint1024_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint1024}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint1024_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint1024.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint1024}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint1024_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint1024.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint1024_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint1024}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint1024_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint1024.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint1024_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint1024}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint1024_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint1024.__wrap(ret[0]);
    }
}

const CompressedFheUint12Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint12_free(ptr >>> 0, 1));

class CompressedFheUint12 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint12.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint12Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint12Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint12_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint12}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint12_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint12.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint12}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint12_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint12.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint12_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint12}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint12_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint12.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint12_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint12}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint12_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint12.__wrap(ret[0]);
    }
}

const CompressedFheUint128Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint128_free(ptr >>> 0, 1));

class CompressedFheUint128 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint128.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint128Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint128Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint128_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint128}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint128_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint128.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint128}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint128_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint128.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint128_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint128}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint128_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint128.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint128_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint128}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint128_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint128.__wrap(ret[0]);
    }
}

const CompressedFheUint14Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint14_free(ptr >>> 0, 1));

class CompressedFheUint14 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint14.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint14Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint14Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint14_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint14}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint14_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint14.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint14}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint14_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint14.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint14_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint14}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint14_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint14.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint14_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint14}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint14_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint14.__wrap(ret[0]);
    }
}

const CompressedFheUint16Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint16_free(ptr >>> 0, 1));

class CompressedFheUint16 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint16.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint16Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint16Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint16_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint16}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint16_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint16.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint16}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint16_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint16.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint16_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint16}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint16_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint16.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint16_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint16}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint16_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint16.__wrap(ret[0]);
    }
}

const CompressedFheUint160Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint160_free(ptr >>> 0, 1));

class CompressedFheUint160 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint160.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint160Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint160Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint160_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint160}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint160_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint160.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint160}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint160_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint160.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint160_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint160}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint160_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint160.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint160_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint160}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint160_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint160.__wrap(ret[0]);
    }
}

const CompressedFheUint2Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint2_free(ptr >>> 0, 1));

class CompressedFheUint2 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint2.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint2Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint2Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint2_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint2}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint2_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint2.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint2}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint2_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint2.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint2_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint2}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint2_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint2.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint2_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint2}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint2_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint2.__wrap(ret[0]);
    }
}

const CompressedFheUint2048Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint2048_free(ptr >>> 0, 1));

class CompressedFheUint2048 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint2048.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint2048Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint2048Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint2048_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint2048}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint2048_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint2048.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint2048}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint2048_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint2048.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint2048_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint2048}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint2048_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint2048.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint2048_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint2048}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint2048_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint2048.__wrap(ret[0]);
    }
}

const CompressedFheUint256Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint256_free(ptr >>> 0, 1));

class CompressedFheUint256 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint256.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint256Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint256Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint256_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint256}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint256_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint256.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint256}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint256_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint256.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint256_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint256}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint256_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint256.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint256_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint256}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint256_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint256.__wrap(ret[0]);
    }
}

const CompressedFheUint32Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint32_free(ptr >>> 0, 1));

class CompressedFheUint32 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint32.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint32Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint32Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint32_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint32}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint32_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint32.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint32}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint32_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint32.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint32_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint32}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint32_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint32.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint32_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint32}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint32_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint32.__wrap(ret[0]);
    }
}

const CompressedFheUint4Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint4_free(ptr >>> 0, 1));

class CompressedFheUint4 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint4.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint4Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint4Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint4_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint4}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint4_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint4.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint4}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint4_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint4.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint4_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint4}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint4_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint4.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint4_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint4}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint4_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint4.__wrap(ret[0]);
    }
}

const CompressedFheUint512Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint512_free(ptr >>> 0, 1));

class CompressedFheUint512 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint512.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint512Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint512Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint512_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint512}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint512_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint512.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint512}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint512_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint512.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint512_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint512}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint512_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint512.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint512_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint512}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint512_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint512.__wrap(ret[0]);
    }
}

const CompressedFheUint6Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint6_free(ptr >>> 0, 1));

class CompressedFheUint6 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint6.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint6Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint6Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint6_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint6}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint6_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint6.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint6}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint6_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint6.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint6_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint6}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint6_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint6.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint6_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint6}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint6_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint6.__wrap(ret[0]);
    }
}

const CompressedFheUint64Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint64_free(ptr >>> 0, 1));

class CompressedFheUint64 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint64.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint64Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint64Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint64_free(ptr, 0);
    }
    /**
     * @param {bigint} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint64}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint64_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint64.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint64}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint64_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint64.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint64_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint64}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint64_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint64.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint64_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint64}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint64_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint64.__wrap(ret[0]);
    }
}

const CompressedFheUint8Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_compressedfheuint8_free(ptr >>> 0, 1));

class CompressedFheUint8 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(CompressedFheUint8.prototype);
        obj.__wbg_ptr = ptr;
        CompressedFheUint8Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        CompressedFheUint8Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_compressedfheuint8_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {CompressedFheUint8}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.compressedfheuint8_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint8.__wrap(ret[0]);
    }
    /**
     * @returns {FheUint8}
     */
    decompress() {
        const ret = wasm$1.compressedfheuint8_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint8.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.compressedfheuint8_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {CompressedFheUint8}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint8_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint8.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.compressedfheuint8_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {CompressedFheUint8}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.compressedfheuint8_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompressedFheUint8.__wrap(ret[0]);
    }
}

const FheBoolFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fhebool_free(ptr >>> 0, 1));

class FheBool {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheBool.prototype);
        obj.__wbg_ptr = ptr;
        FheBoolFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheBoolFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fhebool_free(ptr, 0);
    }
    /**
     * @param {boolean} value
     * @param {TfheClientKey} client_key
     * @returns {FheBool}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fhebool_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheBool.__wrap(ret[0]);
    }
    /**
     * @param {boolean} value
     * @param {TfhePublicKey} public_key
     * @returns {FheBool}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fhebool_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheBool.__wrap(ret[0]);
    }
    /**
     * @param {boolean} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheBool}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fhebool_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheBool.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {boolean}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fhebool_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0] !== 0;
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fhebool_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheBool}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fhebool_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheBool.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fhebool_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheBool}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fhebool_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheBool.__wrap(ret[0]);
    }
}

const FheInt10Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint10_free(ptr >>> 0, 1));

class FheInt10 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheInt10.prototype);
        obj.__wbg_ptr = ptr;
        FheInt10Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheInt10Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheint10_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheInt10}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint10_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt10.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheInt10}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheint10_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt10.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheInt10}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheint10_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt10.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint10_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheint10_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheInt10}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint10_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt10.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheint10_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheInt10}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint10_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt10.__wrap(ret[0]);
    }
}

const FheInt12Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint12_free(ptr >>> 0, 1));

class FheInt12 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheInt12.prototype);
        obj.__wbg_ptr = ptr;
        FheInt12Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheInt12Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheint12_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheInt12}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint12_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt12.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheInt12}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheint12_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt12.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheInt12}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheint12_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt12.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint12_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheint12_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheInt12}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint12_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt12.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheint12_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheInt12}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint12_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt12.__wrap(ret[0]);
    }
}

const FheInt128Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint128_free(ptr >>> 0, 1));

class FheInt128 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheInt128.prototype);
        obj.__wbg_ptr = ptr;
        FheInt128Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheInt128Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheint128_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {FheInt128}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint128_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt128.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfhePublicKey} public_key
     * @returns {FheInt128}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheint128_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt128.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheInt128}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheint128_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt128.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {any}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint128_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return takeFromExternrefTable0$1(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheint128_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheInt128}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint128_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt128.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheint128_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheInt128}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint128_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt128.__wrap(ret[0]);
    }
}

const FheInt14Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint14_free(ptr >>> 0, 1));

class FheInt14 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheInt14.prototype);
        obj.__wbg_ptr = ptr;
        FheInt14Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheInt14Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheint14_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheInt14}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint14_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt14.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheInt14}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheint14_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt14.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheInt14}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheint14_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt14.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint14_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheint14_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheInt14}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint14_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt14.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheint14_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheInt14}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint14_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt14.__wrap(ret[0]);
    }
}

const FheInt16Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint16_free(ptr >>> 0, 1));

class FheInt16 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheInt16.prototype);
        obj.__wbg_ptr = ptr;
        FheInt16Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheInt16Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheint16_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheInt16}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint16_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt16.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheInt16}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheint16_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt16.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheInt16}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheint16_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt16.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint16_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheint16_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheInt16}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint16_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt16.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheint16_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheInt16}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint16_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt16.__wrap(ret[0]);
    }
}

const FheInt160Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint160_free(ptr >>> 0, 1));

class FheInt160 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheInt160.prototype);
        obj.__wbg_ptr = ptr;
        FheInt160Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheInt160Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheint160_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {FheInt160}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint160_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt160.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfhePublicKey} public_key
     * @returns {FheInt160}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheint160_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt160.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheInt160}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheint160_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt160.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {any}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint160_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return takeFromExternrefTable0$1(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheint160_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheInt160}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint160_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt160.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheint160_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheInt160}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint160_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt160.__wrap(ret[0]);
    }
}

const FheInt2Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint2_free(ptr >>> 0, 1));

class FheInt2 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheInt2.prototype);
        obj.__wbg_ptr = ptr;
        FheInt2Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheInt2Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheint2_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheInt2}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint2_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt2.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheInt2}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheint2_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt2.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheInt2}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheint2_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt2.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint2_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheint2_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheInt2}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint2_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt2.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheint2_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheInt2}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint2_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt2.__wrap(ret[0]);
    }
}

const FheInt256Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint256_free(ptr >>> 0, 1));

class FheInt256 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheInt256.prototype);
        obj.__wbg_ptr = ptr;
        FheInt256Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheInt256Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheint256_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {FheInt256}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint256_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt256.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfhePublicKey} public_key
     * @returns {FheInt256}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheint256_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt256.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheInt256}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheint256_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt256.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {any}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint256_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return takeFromExternrefTable0$1(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheint256_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheInt256}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint256_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt256.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheint256_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheInt256}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint256_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt256.__wrap(ret[0]);
    }
}

const FheInt32Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint32_free(ptr >>> 0, 1));

class FheInt32 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheInt32.prototype);
        obj.__wbg_ptr = ptr;
        FheInt32Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheInt32Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheint32_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheInt32}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint32_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt32.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheInt32}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheint32_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt32.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheInt32}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheint32_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt32.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint32_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheint32_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheInt32}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint32_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt32.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheint32_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheInt32}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint32_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt32.__wrap(ret[0]);
    }
}

const FheInt4Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint4_free(ptr >>> 0, 1));

class FheInt4 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheInt4.prototype);
        obj.__wbg_ptr = ptr;
        FheInt4Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheInt4Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheint4_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheInt4}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint4_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt4.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheInt4}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheint4_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt4.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheInt4}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheint4_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt4.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint4_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheint4_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheInt4}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint4_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt4.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheint4_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheInt4}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint4_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt4.__wrap(ret[0]);
    }
}

const FheInt6Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint6_free(ptr >>> 0, 1));

class FheInt6 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheInt6.prototype);
        obj.__wbg_ptr = ptr;
        FheInt6Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheInt6Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheint6_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheInt6}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint6_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt6.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheInt6}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheint6_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt6.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheInt6}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheint6_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt6.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint6_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheint6_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheInt6}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint6_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt6.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheint6_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheInt6}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint6_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt6.__wrap(ret[0]);
    }
}

const FheInt64Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint64_free(ptr >>> 0, 1));

class FheInt64 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheInt64.prototype);
        obj.__wbg_ptr = ptr;
        FheInt64Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheInt64Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheint64_free(ptr, 0);
    }
    /**
     * @param {bigint} value
     * @param {TfheClientKey} client_key
     * @returns {FheInt64}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint64_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt64.__wrap(ret[0]);
    }
    /**
     * @param {bigint} value
     * @param {TfhePublicKey} public_key
     * @returns {FheInt64}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheint64_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt64.__wrap(ret[0]);
    }
    /**
     * @param {bigint} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheInt64}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheint64_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt64.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {bigint}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint64_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheint64_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheInt64}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint64_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt64.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheint64_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheInt64}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint64_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt64.__wrap(ret[0]);
    }
}

const FheInt8Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheint8_free(ptr >>> 0, 1));

class FheInt8 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheInt8.prototype);
        obj.__wbg_ptr = ptr;
        FheInt8Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheInt8Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheint8_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheInt8}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint8_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt8.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheInt8}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheint8_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt8.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheInt8}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheint8_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt8.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheint8_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheint8_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheInt8}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint8_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt8.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheint8_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheInt8}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheint8_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheInt8.__wrap(ret[0]);
    }
}

const FheUint10Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint10_free(ptr >>> 0, 1));

class FheUint10 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint10.prototype);
        obj.__wbg_ptr = ptr;
        FheUint10Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint10Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint10_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint10}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint10_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint10.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint10}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint10_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint10.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint10}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint10_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint10.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint10_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint10_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint10}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint10_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint10.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint10_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint10}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint10_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint10.__wrap(ret[0]);
    }
}

const FheUint1024Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint1024_free(ptr >>> 0, 1));

class FheUint1024 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint1024.prototype);
        obj.__wbg_ptr = ptr;
        FheUint1024Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint1024Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint1024_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint1024}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint1024_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint1024.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint1024}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint1024_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint1024.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint1024}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint1024_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint1024.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {any}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint1024_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return takeFromExternrefTable0$1(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint1024_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint1024}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint1024_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint1024.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint1024_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint1024}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint1024_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint1024.__wrap(ret[0]);
    }
}

const FheUint12Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint12_free(ptr >>> 0, 1));

class FheUint12 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint12.prototype);
        obj.__wbg_ptr = ptr;
        FheUint12Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint12Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint12_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint12}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint12_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint12.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint12}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint12_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint12.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint12}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint12_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint12.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint12_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint12_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint12}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint12_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint12.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint12_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint12}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint12_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint12.__wrap(ret[0]);
    }
}

const FheUint128Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint128_free(ptr >>> 0, 1));

class FheUint128 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint128.prototype);
        obj.__wbg_ptr = ptr;
        FheUint128Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint128Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint128_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint128}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint128_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint128.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint128}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint128_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint128.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint128}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint128_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint128.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {any}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint128_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return takeFromExternrefTable0$1(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint128_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint128}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint128_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint128.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint128_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint128}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint128_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint128.__wrap(ret[0]);
    }
}

const FheUint14Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint14_free(ptr >>> 0, 1));

class FheUint14 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint14.prototype);
        obj.__wbg_ptr = ptr;
        FheUint14Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint14Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint14_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint14}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint14_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint14.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint14}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint14_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint14.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint14}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint14_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint14.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint14_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint14_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint14}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint14_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint14.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint14_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint14}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint14_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint14.__wrap(ret[0]);
    }
}

const FheUint16Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint16_free(ptr >>> 0, 1));

class FheUint16 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint16.prototype);
        obj.__wbg_ptr = ptr;
        FheUint16Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint16Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint16_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint16}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint16_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint16.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint16}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint16_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint16.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint16}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint16_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint16.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint16_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint16_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint16}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint16_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint16.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint16_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint16}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint16_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint16.__wrap(ret[0]);
    }
}

const FheUint160Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint160_free(ptr >>> 0, 1));

class FheUint160 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint160.prototype);
        obj.__wbg_ptr = ptr;
        FheUint160Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint160Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint160_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint160}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint160_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint160.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint160}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint160_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint160.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint160}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint160_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint160.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {any}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint160_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return takeFromExternrefTable0$1(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint160_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint160}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint160_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint160.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint160_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint160}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint160_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint160.__wrap(ret[0]);
    }
}

const FheUint2Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint2_free(ptr >>> 0, 1));

class FheUint2 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint2.prototype);
        obj.__wbg_ptr = ptr;
        FheUint2Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint2Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint2_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint2}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint2_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint2.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint2}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint2_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint2.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint2}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint2_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint2.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint2_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint2_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint2}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint2_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint2.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint2_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint2}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint2_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint2.__wrap(ret[0]);
    }
}

const FheUint2048Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint2048_free(ptr >>> 0, 1));

class FheUint2048 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint2048.prototype);
        obj.__wbg_ptr = ptr;
        FheUint2048Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint2048Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint2048_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint2048}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint2048_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint2048.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint2048}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint2048_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint2048.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint2048}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint2048_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint2048.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {any}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint2048_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return takeFromExternrefTable0$1(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint2048_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint2048}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint2048_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint2048.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint2048_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint2048}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint2048_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint2048.__wrap(ret[0]);
    }
}

const FheUint256Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint256_free(ptr >>> 0, 1));

class FheUint256 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint256.prototype);
        obj.__wbg_ptr = ptr;
        FheUint256Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint256Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint256_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint256}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint256_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint256.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint256}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint256_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint256.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint256}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint256_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint256.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {any}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint256_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return takeFromExternrefTable0$1(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint256_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint256}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint256_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint256.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint256_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint256}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint256_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint256.__wrap(ret[0]);
    }
}

const FheUint32Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint32_free(ptr >>> 0, 1));

class FheUint32 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint32.prototype);
        obj.__wbg_ptr = ptr;
        FheUint32Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint32Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint32_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint32}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint32_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint32.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint32}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint32_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint32.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint32}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint32_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint32.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint32_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0] >>> 0;
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint32_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint32}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint32_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint32.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint32_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint32}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint32_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint32.__wrap(ret[0]);
    }
}

const FheUint4Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint4_free(ptr >>> 0, 1));

class FheUint4 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint4.prototype);
        obj.__wbg_ptr = ptr;
        FheUint4Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint4Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint4_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint4}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint4_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint4.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint4}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint4_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint4.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint4}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint4_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint4.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint4_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint4_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint4}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint4_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint4.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint4_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint4}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint4_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint4.__wrap(ret[0]);
    }
}

const FheUint512Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint512_free(ptr >>> 0, 1));

class FheUint512 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint512.prototype);
        obj.__wbg_ptr = ptr;
        FheUint512Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint512Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint512_free(ptr, 0);
    }
    /**
     * @param {any} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint512}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint512_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint512.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint512}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint512_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint512.__wrap(ret[0]);
    }
    /**
     * @param {any} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint512}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint512_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint512.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {any}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint512_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return takeFromExternrefTable0$1(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint512_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint512}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint512_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint512.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint512_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint512}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint512_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint512.__wrap(ret[0]);
    }
}

const FheUint6Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint6_free(ptr >>> 0, 1));

class FheUint6 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint6.prototype);
        obj.__wbg_ptr = ptr;
        FheUint6Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint6Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint6_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint6}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint6_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint6.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint6}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint6_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint6.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint6}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint6_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint6.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint6_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint6_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint6}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint6_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint6.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint6_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint6}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint6_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint6.__wrap(ret[0]);
    }
}

const FheUint64Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint64_free(ptr >>> 0, 1));

class FheUint64 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint64.prototype);
        obj.__wbg_ptr = ptr;
        FheUint64Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint64Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint64_free(ptr, 0);
    }
    /**
     * @param {bigint} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint64}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint64_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint64.__wrap(ret[0]);
    }
    /**
     * @param {bigint} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint64}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint64_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint64.__wrap(ret[0]);
    }
    /**
     * @param {bigint} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint64}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint64_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint64.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {bigint}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint64_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return BigInt.asUintN(64, ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint64_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint64}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint64_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint64.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint64_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint64}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint64_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint64.__wrap(ret[0]);
    }
}

const FheUint8Finalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_fheuint8_free(ptr >>> 0, 1));

class FheUint8 {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(FheUint8.prototype);
        obj.__wbg_ptr = ptr;
        FheUint8Finalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        FheUint8Finalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_fheuint8_free(ptr, 0);
    }
    /**
     * @param {number} value
     * @param {TfheClientKey} client_key
     * @returns {FheUint8}
     */
    static encrypt_with_client_key(value, client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint8_encrypt_with_client_key(value, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint8.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfhePublicKey} public_key
     * @returns {FheUint8}
     */
    static encrypt_with_public_key(value, public_key) {
        _assertClass$1(public_key, TfhePublicKey);
        const ret = wasm$1.fheuint8_encrypt_with_public_key(value, public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint8.__wrap(ret[0]);
    }
    /**
     * @param {number} value
     * @param {TfheCompressedPublicKey} compressed_public_key
     * @returns {FheUint8}
     */
    static encrypt_with_compressed_public_key(value, compressed_public_key) {
        _assertClass$1(compressed_public_key, TfheCompressedPublicKey);
        const ret = wasm$1.fheuint8_encrypt_with_compressed_public_key(value, compressed_public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint8.__wrap(ret[0]);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {number}
     */
    decrypt(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.fheuint8_decrypt(this.__wbg_ptr, client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ret[0];
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.fheuint8_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {FheUint8}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint8_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint8.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.fheuint8_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {FheUint8}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.fheuint8_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return FheUint8.__wrap(ret[0]);
    }
}

const ProvenCompactCiphertextListFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_provencompactciphertextlist_free(ptr >>> 0, 1));

class ProvenCompactCiphertextList {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ProvenCompactCiphertextList.prototype);
        obj.__wbg_ptr = ptr;
        ProvenCompactCiphertextListFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ProvenCompactCiphertextListFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_provencompactciphertextlist_free(ptr, 0);
    }
    /**
     * @param {TfheCompactPublicKey} public_key
     * @returns {CompactCiphertextListBuilder}
     */
    static builder(public_key) {
        _assertClass$1(public_key, TfheCompactPublicKey);
        const ret = wasm$1.provencompactciphertextlist_builder(public_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompactCiphertextListBuilder.__wrap(ret[0]);
    }
    /**
     * @returns {number}
     */
    len() {
        const ret = wasm$1.compactciphertextlistexpander_len(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {boolean}
     */
    is_empty() {
        const ret = wasm$1.compactciphertextlistexpander_is_empty(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @param {number} index
     * @returns {FheTypes | undefined}
     */
    get_kind_of(index) {
        const ret = wasm$1.provencompactciphertextlist_get_kind_of(this.__wbg_ptr, index);
        return ret === 31 ? undefined : ret;
    }
    /**
     * @param {CompactPkeCrs} crs
     * @param {TfheCompactPublicKey} public_key
     * @param {Uint8Array} metadata
     * @returns {CompactCiphertextListExpander}
     */
    verify_and_expand(crs, public_key, metadata) {
        _assertClass$1(crs, CompactPkeCrs);
        _assertClass$1(public_key, TfheCompactPublicKey);
        const ptr0 = passArray8ToWasm0$1(metadata, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.provencompactciphertextlist_verify_and_expand(this.__wbg_ptr, crs.__wbg_ptr, public_key.__wbg_ptr, ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompactCiphertextListExpander.__wrap(ret[0]);
    }
    /**
     * @returns {CompactCiphertextListExpander}
     */
    expand_without_verification() {
        const ret = wasm$1.provencompactciphertextlist_expand_without_verification(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return CompactCiphertextListExpander.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.provencompactciphertextlist_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {ProvenCompactCiphertextList}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.provencompactciphertextlist_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ProvenCompactCiphertextList.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.provencompactciphertextlist_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {ProvenCompactCiphertextList}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.provencompactciphertextlist_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ProvenCompactCiphertextList.__wrap(ret[0]);
    }
}

const ShortintFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_shortint_free(ptr >>> 0, 1));

class Shortint {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ShortintFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_shortint_free(ptr, 0);
    }
    /**
     * @param {number} std_dev
     * @returns {ShortintNoiseDistribution}
     */
    static new_gaussian_from_std_dev(std_dev) {
        const ret = wasm$1.shortint_new_gaussian_from_std_dev(std_dev);
        return ShortintNoiseDistribution.__wrap(ret);
    }
    /**
     * @param {number} bound_log2
     * @returns {ShortintNoiseDistribution}
     */
    static try_new_t_uniform(bound_log2) {
        const ret = wasm$1.shortint_try_new_t_uniform(bound_log2);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ShortintNoiseDistribution.__wrap(ret[0]);
    }
    /**
     * @param {number} lwe_dimension
     * @param {number} glwe_dimension
     * @param {number} polynomial_size
     * @param {ShortintNoiseDistribution} lwe_noise_distribution
     * @param {ShortintNoiseDistribution} glwe_noise_distribution
     * @param {number} pbs_base_log
     * @param {number} pbs_level
     * @param {number} ks_base_log
     * @param {number} ks_level
     * @param {bigint} message_modulus
     * @param {bigint} carry_modulus
     * @param {bigint} max_noise_level
     * @param {number} log2_p_fail
     * @param {number} modulus_power_of_2_exponent
     * @param {ShortintEncryptionKeyChoice} encryption_key_choice
     * @returns {ShortintParameters}
     */
    static new_parameters(lwe_dimension, glwe_dimension, polynomial_size, lwe_noise_distribution, glwe_noise_distribution, pbs_base_log, pbs_level, ks_base_log, ks_level, message_modulus, carry_modulus, max_noise_level, log2_p_fail, modulus_power_of_2_exponent, encryption_key_choice) {
        _assertClass$1(lwe_noise_distribution, ShortintNoiseDistribution);
        _assertClass$1(glwe_noise_distribution, ShortintNoiseDistribution);
        const ret = wasm$1.shortint_new_parameters(lwe_dimension, glwe_dimension, polynomial_size, lwe_noise_distribution.__wbg_ptr, glwe_noise_distribution.__wbg_ptr, pbs_base_log, pbs_level, ks_base_log, ks_level, message_modulus, carry_modulus, max_noise_level, log2_p_fail, modulus_power_of_2_exponent, encryption_key_choice);
        return ShortintParameters.__wrap(ret);
    }
    /**
     * @param {bigint} seed_high_bytes
     * @param {bigint} seed_low_bytes
     * @param {ShortintParameters} parameters
     * @returns {ShortintClientKey}
     */
    static new_client_key_from_seed_and_parameters(seed_high_bytes, seed_low_bytes, parameters) {
        _assertClass$1(parameters, ShortintParameters);
        const ret = wasm$1.shortint_new_client_key_from_seed_and_parameters(seed_high_bytes, seed_low_bytes, parameters.__wbg_ptr);
        return ShortintClientKey.__wrap(ret);
    }
    /**
     * @param {ShortintParameters} parameters
     * @returns {ShortintClientKey}
     */
    static new_client_key(parameters) {
        _assertClass$1(parameters, ShortintParameters);
        const ret = wasm$1.shortint_new_client_key(parameters.__wbg_ptr);
        return ShortintClientKey.__wrap(ret);
    }
    /**
     * @param {ShortintClientKey} client_key
     * @returns {ShortintPublicKey}
     */
    static new_public_key(client_key) {
        _assertClass$1(client_key, ShortintClientKey);
        const ret = wasm$1.shortint_new_public_key(client_key.__wbg_ptr);
        return ShortintPublicKey.__wrap(ret);
    }
    /**
     * @param {ShortintClientKey} client_key
     * @returns {ShortintCompressedPublicKey}
     */
    static new_compressed_public_key(client_key) {
        _assertClass$1(client_key, ShortintClientKey);
        const ret = wasm$1.shortint_new_compressed_public_key(client_key.__wbg_ptr);
        return ShortintCompressedPublicKey.__wrap(ret);
    }
    /**
     * @param {ShortintClientKey} client_key
     * @returns {ShortintCompressedServerKey}
     */
    static new_compressed_server_key(client_key) {
        _assertClass$1(client_key, ShortintClientKey);
        const ret = wasm$1.shortint_new_compressed_server_key(client_key.__wbg_ptr);
        return ShortintCompressedServerKey.__wrap(ret);
    }
    /**
     * @param {ShortintClientKey} client_key
     * @param {bigint} message
     * @returns {ShortintCiphertext}
     */
    static encrypt(client_key, message) {
        _assertClass$1(client_key, ShortintClientKey);
        const ret = wasm$1.shortint_encrypt(client_key.__wbg_ptr, message);
        return ShortintCiphertext.__wrap(ret);
    }
    /**
     * @param {ShortintClientKey} client_key
     * @param {bigint} message
     * @returns {ShortintCompressedCiphertext}
     */
    static encrypt_compressed(client_key, message) {
        _assertClass$1(client_key, ShortintClientKey);
        const ret = wasm$1.shortint_encrypt_compressed(client_key.__wbg_ptr, message);
        return ShortintCompressedCiphertext.__wrap(ret);
    }
    /**
     * @param {ShortintCompressedCiphertext} compressed_ciphertext
     * @returns {ShortintCiphertext}
     */
    static decompress_ciphertext(compressed_ciphertext) {
        _assertClass$1(compressed_ciphertext, ShortintCompressedCiphertext);
        const ret = wasm$1.shortint_decompress_ciphertext(compressed_ciphertext.__wbg_ptr);
        return ShortintCiphertext.__wrap(ret);
    }
    /**
     * @param {ShortintPublicKey} public_key
     * @param {bigint} message
     * @returns {ShortintCiphertext}
     */
    static encrypt_with_public_key(public_key, message) {
        _assertClass$1(public_key, ShortintPublicKey);
        const ret = wasm$1.shortint_encrypt_with_public_key(public_key.__wbg_ptr, message);
        return ShortintCiphertext.__wrap(ret);
    }
    /**
     * @param {ShortintCompressedPublicKey} public_key
     * @param {bigint} message
     * @returns {ShortintCiphertext}
     */
    static encrypt_with_compressed_public_key(public_key, message) {
        _assertClass$1(public_key, ShortintCompressedPublicKey);
        const ret = wasm$1.shortint_encrypt_with_compressed_public_key(public_key.__wbg_ptr, message);
        return ShortintCiphertext.__wrap(ret);
    }
    /**
     * @param {ShortintClientKey} client_key
     * @param {ShortintCiphertext} ct
     * @returns {bigint}
     */
    static decrypt(client_key, ct) {
        _assertClass$1(client_key, ShortintClientKey);
        _assertClass$1(ct, ShortintCiphertext);
        const ret = wasm$1.shortint_decrypt(client_key.__wbg_ptr, ct.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {ShortintCiphertext} ciphertext
     * @returns {Uint8Array}
     */
    static serialize_ciphertext(ciphertext) {
        _assertClass$1(ciphertext, ShortintCiphertext);
        const ret = wasm$1.shortint_serialize_ciphertext(ciphertext.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {ShortintCiphertext}
     */
    static deserialize_ciphertext(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.shortint_deserialize_ciphertext(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ShortintCiphertext.__wrap(ret[0]);
    }
    /**
     * @param {ShortintCompressedCiphertext} ciphertext
     * @returns {Uint8Array}
     */
    static serialize_compressed_ciphertext(ciphertext) {
        _assertClass$1(ciphertext, ShortintCompressedCiphertext);
        const ret = wasm$1.shortint_serialize_compressed_ciphertext(ciphertext.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {ShortintCompressedCiphertext}
     */
    static deserialize_compressed_ciphertext(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.shortint_deserialize_compressed_ciphertext(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ShortintCompressedCiphertext.__wrap(ret[0]);
    }
    /**
     * @param {ShortintClientKey} client_key
     * @returns {Uint8Array}
     */
    static serialize_client_key(client_key) {
        _assertClass$1(client_key, ShortintClientKey);
        const ret = wasm$1.shortint_serialize_client_key(client_key.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {ShortintClientKey}
     */
    static deserialize_client_key(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.shortint_deserialize_client_key(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ShortintClientKey.__wrap(ret[0]);
    }
    /**
     * @param {ShortintPublicKey} public_key
     * @returns {Uint8Array}
     */
    static serialize_public_key(public_key) {
        _assertClass$1(public_key, ShortintPublicKey);
        const ret = wasm$1.shortint_serialize_public_key(public_key.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {ShortintPublicKey}
     */
    static deserialize_public_key(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.shortint_deserialize_public_key(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ShortintPublicKey.__wrap(ret[0]);
    }
    /**
     * @param {ShortintCompressedPublicKey} public_key
     * @returns {Uint8Array}
     */
    static serialize_compressed_public_key(public_key) {
        _assertClass$1(public_key, ShortintCompressedPublicKey);
        const ret = wasm$1.shortint_serialize_compressed_public_key(public_key.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {ShortintCompressedPublicKey}
     */
    static deserialize_compressed_public_key(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.shortint_deserialize_compressed_public_key(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ShortintCompressedPublicKey.__wrap(ret[0]);
    }
    /**
     * @param {ShortintCompressedServerKey} server_key
     * @returns {Uint8Array}
     */
    static serialize_compressed_server_key(server_key) {
        _assertClass$1(server_key, ShortintCompressedServerKey);
        const ret = wasm$1.shortint_serialize_compressed_server_key(server_key.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {ShortintCompressedServerKey}
     */
    static deserialize_compressed_server_key(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.shortint_deserialize_compressed_server_key(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ShortintCompressedServerKey.__wrap(ret[0]);
    }
}

const ShortintCiphertextFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintciphertext_free(ptr >>> 0, 1));

class ShortintCiphertext {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ShortintCiphertext.prototype);
        obj.__wbg_ptr = ptr;
        ShortintCiphertextFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ShortintCiphertextFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_shortintciphertext_free(ptr, 0);
    }
}

const ShortintClientKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintclientkey_free(ptr >>> 0, 1));

class ShortintClientKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ShortintClientKey.prototype);
        obj.__wbg_ptr = ptr;
        ShortintClientKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ShortintClientKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_shortintclientkey_free(ptr, 0);
    }
}

const ShortintCompactPublicKeyEncryptionParametersFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintcompactpublickeyencryptionparameters_free(ptr >>> 0, 1));

class ShortintCompactPublicKeyEncryptionParameters {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ShortintCompactPublicKeyEncryptionParameters.prototype);
        obj.__wbg_ptr = ptr;
        ShortintCompactPublicKeyEncryptionParametersFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ShortintCompactPublicKeyEncryptionParametersFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_shortintcompactpublickeyencryptionparameters_free(ptr, 0);
    }
    /**
     * @param {ShortintCompactPublicKeyEncryptionParametersName} name
     */
    constructor(name) {
        const ret = wasm$1.shortintcompactpublickeyencryptionparameters_new(name);
        this.__wbg_ptr = ret >>> 0;
        ShortintCompactPublicKeyEncryptionParametersFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @param {number} encryption_lwe_dimension
     * @param {ShortintNoiseDistribution} encryption_noise_distribution
     * @param {bigint} message_modulus
     * @param {bigint} carry_modulus
     * @param {number} modulus_power_of_2_exponent
     * @param {number} ks_base_log
     * @param {number} ks_level
     * @param {ShortintEncryptionKeyChoice} encryption_key_choice
     * @returns {ShortintCompactPublicKeyEncryptionParameters}
     */
    static new_parameters(encryption_lwe_dimension, encryption_noise_distribution, message_modulus, carry_modulus, modulus_power_of_2_exponent, ks_base_log, ks_level, encryption_key_choice) {
        _assertClass$1(encryption_noise_distribution, ShortintNoiseDistribution);
        const ret = wasm$1.shortintcompactpublickeyencryptionparameters_new_parameters(encryption_lwe_dimension, encryption_noise_distribution.__wbg_ptr, message_modulus, carry_modulus, modulus_power_of_2_exponent, ks_base_log, ks_level, encryption_key_choice);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return ShortintCompactPublicKeyEncryptionParameters.__wrap(ret[0]);
    }
}

const ShortintCompressedCiphertextFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintcompressedciphertext_free(ptr >>> 0, 1));

class ShortintCompressedCiphertext {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ShortintCompressedCiphertext.prototype);
        obj.__wbg_ptr = ptr;
        ShortintCompressedCiphertextFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ShortintCompressedCiphertextFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_shortintcompressedciphertext_free(ptr, 0);
    }
}

const ShortintCompressedPublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintcompressedpublickey_free(ptr >>> 0, 1));

class ShortintCompressedPublicKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ShortintCompressedPublicKey.prototype);
        obj.__wbg_ptr = ptr;
        ShortintCompressedPublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ShortintCompressedPublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_shortintcompressedpublickey_free(ptr, 0);
    }
}

const ShortintCompressedServerKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintcompressedserverkey_free(ptr >>> 0, 1));

class ShortintCompressedServerKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ShortintCompressedServerKey.prototype);
        obj.__wbg_ptr = ptr;
        ShortintCompressedServerKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ShortintCompressedServerKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_shortintcompressedserverkey_free(ptr, 0);
    }
}

const ShortintNoiseDistributionFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintnoisedistribution_free(ptr >>> 0, 1));

class ShortintNoiseDistribution {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ShortintNoiseDistribution.prototype);
        obj.__wbg_ptr = ptr;
        ShortintNoiseDistributionFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ShortintNoiseDistributionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_shortintnoisedistribution_free(ptr, 0);
    }
}

const ShortintParametersFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintparameters_free(ptr >>> 0, 1));

class ShortintParameters {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ShortintParameters.prototype);
        obj.__wbg_ptr = ptr;
        ShortintParametersFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ShortintParametersFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_shortintparameters_free(ptr, 0);
    }
    /**
     * @returns {number}
     */
    lwe_dimension() {
        const ret = wasm$1.shortintparameters_lwe_dimension(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} new_value
     */
    set_lwe_dimension(new_value) {
        wasm$1.shortintparameters_set_lwe_dimension(this.__wbg_ptr, new_value);
    }
    /**
     * @returns {number}
     */
    glwe_dimension() {
        const ret = wasm$1.shortintparameters_glwe_dimension(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} new_value
     */
    set_glwe_dimension(new_value) {
        wasm$1.shortintparameters_set_glwe_dimension(this.__wbg_ptr, new_value);
    }
    /**
     * @returns {number}
     */
    polynomial_size() {
        const ret = wasm$1.shortintparameters_polynomial_size(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} new_value
     */
    set_polynomial_size(new_value) {
        wasm$1.shortintparameters_set_polynomial_size(this.__wbg_ptr, new_value);
    }
    /**
     * @returns {ShortintNoiseDistribution}
     */
    lwe_noise_distribution() {
        const ret = wasm$1.shortintparameters_glwe_noise_distribution(this.__wbg_ptr);
        return ShortintNoiseDistribution.__wrap(ret);
    }
    /**
     * @param {ShortintNoiseDistribution} new_value
     */
    set_lwe_noise_distribution(new_value) {
        _assertClass$1(new_value, ShortintNoiseDistribution);
        wasm$1.shortintparameters_set_lwe_noise_distribution(this.__wbg_ptr, new_value.__wbg_ptr);
    }
    /**
     * @returns {ShortintNoiseDistribution}
     */
    glwe_noise_distribution() {
        const ret = wasm$1.shortintparameters_glwe_noise_distribution(this.__wbg_ptr);
        return ShortintNoiseDistribution.__wrap(ret);
    }
    /**
     * @param {ShortintNoiseDistribution} new_value
     */
    set_glwe_noise_distribution(new_value) {
        _assertClass$1(new_value, ShortintNoiseDistribution);
        wasm$1.shortintparameters_set_glwe_noise_distribution(this.__wbg_ptr, new_value.__wbg_ptr);
    }
    /**
     * @returns {number}
     */
    pbs_base_log() {
        const ret = wasm$1.shortintparameters_pbs_base_log(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} new_value
     */
    set_pbs_base_log(new_value) {
        wasm$1.shortintparameters_set_pbs_base_log(this.__wbg_ptr, new_value);
    }
    /**
     * @returns {number}
     */
    pbs_level() {
        const ret = wasm$1.shortintparameters_pbs_level(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} new_value
     */
    set_pbs_level(new_value) {
        wasm$1.shortintparameters_set_pbs_level(this.__wbg_ptr, new_value);
    }
    /**
     * @returns {number}
     */
    ks_base_log() {
        const ret = wasm$1.shortintparameters_ks_base_log(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} new_value
     */
    set_ks_base_log(new_value) {
        wasm$1.shortintparameters_set_ks_base_log(this.__wbg_ptr, new_value);
    }
    /**
     * @returns {number}
     */
    ks_level() {
        const ret = wasm$1.shortintparameters_ks_level(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} new_value
     */
    set_ks_level(new_value) {
        wasm$1.shortintparameters_set_ks_level(this.__wbg_ptr, new_value);
    }
    /**
     * @returns {bigint}
     */
    message_modulus() {
        const ret = wasm$1.shortintparameters_message_modulus(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} new_value
     */
    set_message_modulus(new_value) {
        wasm$1.shortintparameters_set_message_modulus(this.__wbg_ptr, new_value);
    }
    /**
     * @returns {bigint}
     */
    carry_modulus() {
        const ret = wasm$1.shortintparameters_carry_modulus(this.__wbg_ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
     * @param {bigint} new_value
     */
    set_carry_modulus(new_value) {
        wasm$1.shortintparameters_set_carry_modulus(this.__wbg_ptr, new_value);
    }
    /**
     * @returns {ShortintEncryptionKeyChoice}
     */
    encryption_key_choice() {
        const ret = wasm$1.shortintparameters_encryption_key_choice(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {ShortintEncryptionKeyChoice} new_value
     */
    set_encryption_key_choice(new_value) {
        wasm$1.shortintparameters_set_encryption_key_choice(this.__wbg_ptr, new_value);
    }
    /**
     * @param {ShortintParametersName} name
     */
    constructor(name) {
        const ret = wasm$1.shortintparameters_new(name);
        this.__wbg_ptr = ret >>> 0;
        ShortintParametersFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
}

const ShortintPublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_shortintpublickey_free(ptr >>> 0, 1));

class ShortintPublicKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ShortintPublicKey.prototype);
        obj.__wbg_ptr = ptr;
        ShortintPublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ShortintPublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_shortintpublickey_free(ptr, 0);
    }
}

const TfheClientKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tfheclientkey_free(ptr >>> 0, 1));

class TfheClientKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TfheClientKey.prototype);
        obj.__wbg_ptr = ptr;
        TfheClientKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TfheClientKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tfheclientkey_free(ptr, 0);
    }
    /**
     * @param {TfheConfig} config
     * @returns {TfheClientKey}
     */
    static generate(config) {
        _assertClass$1(config, TfheConfig);
        const ret = wasm$1.tfheclientkey_generate(config.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheClientKey.__wrap(ret[0]);
    }
    /**
     * @param {TfheConfig} config
     * @param {any} seed
     * @returns {TfheClientKey}
     */
    static generate_with_seed(config, seed) {
        _assertClass$1(config, TfheConfig);
        const ret = wasm$1.tfheclientkey_generate_with_seed(config.__wbg_ptr, seed);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheClientKey.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.tfheclientkey_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {TfheClientKey}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.tfheclientkey_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheClientKey.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.tfheclientkey_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {TfheClientKey}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.tfheclientkey_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheClientKey.__wrap(ret[0]);
    }
}

const TfheCompactPublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tfhecompactpublickey_free(ptr >>> 0, 1));

class TfheCompactPublicKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TfheCompactPublicKey.prototype);
        obj.__wbg_ptr = ptr;
        TfheCompactPublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TfheCompactPublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tfhecompactpublickey_free(ptr, 0);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {TfheCompactPublicKey}
     */
    static new(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.tfhecompactpublickey_new(client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheCompactPublicKey.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.tfhecompactpublickey_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {TfheCompactPublicKey}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.tfhecompactpublickey_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheCompactPublicKey.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.tfhecompactpublickey_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {TfheCompactPublicKey}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.tfhecompactpublickey_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheCompactPublicKey.__wrap(ret[0]);
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @param {ShortintCompactPublicKeyEncryptionParameters} conformance_params
     * @returns {TfheCompactPublicKey}
     */
    static safe_deserialize_conformant(buffer, serialized_size_limit, conformance_params) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        _assertClass$1(conformance_params, ShortintCompactPublicKeyEncryptionParameters);
        const ret = wasm$1.tfhecompactpublickey_safe_deserialize_conformant(ptr0, len0, serialized_size_limit, conformance_params.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheCompactPublicKey.__wrap(ret[0]);
    }
}

const TfheCompressedCompactPublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tfhecompressedcompactpublickey_free(ptr >>> 0, 1));

class TfheCompressedCompactPublicKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TfheCompressedCompactPublicKey.prototype);
        obj.__wbg_ptr = ptr;
        TfheCompressedCompactPublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TfheCompressedCompactPublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tfhecompressedcompactpublickey_free(ptr, 0);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {TfheCompressedCompactPublicKey}
     */
    static new(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.tfhecompressedcompactpublickey_new(client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheCompressedCompactPublicKey.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.tfhecompressedcompactpublickey_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {TfheCompressedCompactPublicKey}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.tfhecompressedcompactpublickey_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheCompressedCompactPublicKey.__wrap(ret[0]);
    }
    /**
     * @returns {TfheCompactPublicKey}
     */
    decompress() {
        const ret = wasm$1.tfhecompressedcompactpublickey_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheCompactPublicKey.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.tfhecompressedcompactpublickey_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {TfheCompressedCompactPublicKey}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.tfhecompressedcompactpublickey_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheCompressedCompactPublicKey.__wrap(ret[0]);
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @param {ShortintCompactPublicKeyEncryptionParameters} conformance_params
     * @returns {TfheCompressedCompactPublicKey}
     */
    static safe_deserialize_conformant(buffer, serialized_size_limit, conformance_params) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        _assertClass$1(conformance_params, ShortintCompactPublicKeyEncryptionParameters);
        const ret = wasm$1.tfhecompressedcompactpublickey_safe_deserialize_conformant(ptr0, len0, serialized_size_limit, conformance_params.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheCompressedCompactPublicKey.__wrap(ret[0]);
    }
}

const TfheCompressedPublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tfhecompressedpublickey_free(ptr >>> 0, 1));

class TfheCompressedPublicKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TfheCompressedPublicKey.prototype);
        obj.__wbg_ptr = ptr;
        TfheCompressedPublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TfheCompressedPublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tfhecompressedpublickey_free(ptr, 0);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {TfheCompressedPublicKey}
     */
    static new(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.tfhecompressedpublickey_new(client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheCompressedPublicKey.__wrap(ret[0]);
    }
    /**
     * @returns {TfhePublicKey}
     */
    decompress() {
        const ret = wasm$1.tfhecompressedpublickey_decompress(this.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfhePublicKey.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.tfhecompressedpublickey_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {TfheCompressedPublicKey}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.tfhecompressedpublickey_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheCompressedPublicKey.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.tfhecompressedpublickey_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {TfheCompressedPublicKey}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.tfhecompressedpublickey_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheCompressedPublicKey.__wrap(ret[0]);
    }
}

const TfheCompressedServerKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tfhecompressedserverkey_free(ptr >>> 0, 1));

class TfheCompressedServerKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TfheCompressedServerKey.prototype);
        obj.__wbg_ptr = ptr;
        TfheCompressedServerKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TfheCompressedServerKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tfhecompressedserverkey_free(ptr, 0);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {TfheCompressedServerKey}
     */
    static new(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.tfhecompressedserverkey_new(client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheCompressedServerKey.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.tfhecompressedserverkey_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {TfheCompressedServerKey}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.tfhecompressedserverkey_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheCompressedServerKey.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.tfhecompressedserverkey_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {TfheCompressedServerKey}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.tfhecompressedserverkey_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheCompressedServerKey.__wrap(ret[0]);
    }
}

const TfheConfigFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tfheconfig_free(ptr >>> 0, 1));

class TfheConfig {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TfheConfig.prototype);
        obj.__wbg_ptr = ptr;
        TfheConfigFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TfheConfigFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tfheconfig_free(ptr, 0);
    }
}

const TfheConfigBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tfheconfigbuilder_free(ptr >>> 0, 1));

class TfheConfigBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TfheConfigBuilder.prototype);
        obj.__wbg_ptr = ptr;
        TfheConfigBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TfheConfigBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tfheconfigbuilder_free(ptr, 0);
    }
    /**
     * @returns {TfheConfigBuilder}
     */
    static default() {
        const ret = wasm$1.tfheconfigbuilder_default();
        return TfheConfigBuilder.__wrap(ret);
    }
    /**
     * @param {ShortintParameters} block_parameters
     * @returns {TfheConfigBuilder}
     */
    static with_custom_parameters(block_parameters) {
        _assertClass$1(block_parameters, ShortintParameters);
        const ret = wasm$1.tfheconfigbuilder_with_custom_parameters(block_parameters.__wbg_ptr);
        return TfheConfigBuilder.__wrap(ret);
    }
    /**
     * @param {ShortintParameters} block_parameters
     * @returns {TfheConfigBuilder}
     */
    use_custom_parameters(block_parameters) {
        const ptr = this.__destroy_into_raw();
        _assertClass$1(block_parameters, ShortintParameters);
        const ret = wasm$1.tfheconfigbuilder_use_custom_parameters(ptr, block_parameters.__wbg_ptr);
        return TfheConfigBuilder.__wrap(ret);
    }
    /**
     * @param {ShortintCompactPublicKeyEncryptionParameters} compact_public_key_parameters
     * @returns {TfheConfigBuilder}
     */
    use_dedicated_compact_public_key_parameters(compact_public_key_parameters) {
        const ptr = this.__destroy_into_raw();
        _assertClass$1(compact_public_key_parameters, ShortintCompactPublicKeyEncryptionParameters);
        const ret = wasm$1.tfheconfigbuilder_use_dedicated_compact_public_key_parameters(ptr, compact_public_key_parameters.__wbg_ptr);
        return TfheConfigBuilder.__wrap(ret);
    }
    /**
     * @returns {TfheConfig}
     */
    build() {
        const ptr = this.__destroy_into_raw();
        const ret = wasm$1.tfheconfigbuilder_build(ptr);
        return TfheConfig.__wrap(ret);
    }
}

const TfhePublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tfhepublickey_free(ptr >>> 0, 1));

class TfhePublicKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TfhePublicKey.prototype);
        obj.__wbg_ptr = ptr;
        TfhePublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TfhePublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tfhepublickey_free(ptr, 0);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {TfhePublicKey}
     */
    static new(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.tfhepublickey_new(client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfhePublicKey.__wrap(ret[0]);
    }
    /**
     * @returns {Uint8Array}
     */
    serialize() {
        const ret = wasm$1.tfhepublickey_serialize(this.__wbg_ptr);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @returns {TfhePublicKey}
     */
    static deserialize(buffer) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.tfhepublickey_deserialize(ptr0, len0);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfhePublicKey.__wrap(ret[0]);
    }
    /**
     * @param {bigint} serialized_size_limit
     * @returns {Uint8Array}
     */
    safe_serialize(serialized_size_limit) {
        const ret = wasm$1.tfhepublickey_safe_serialize(this.__wbg_ptr, serialized_size_limit);
        if (ret[3]) {
            throw takeFromExternrefTable0$1(ret[2]);
        }
        var v1 = getArrayU8FromWasm0$1(ret[0], ret[1]).slice();
        wasm$1.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} buffer
     * @param {bigint} serialized_size_limit
     * @returns {TfhePublicKey}
     */
    static safe_deserialize(buffer, serialized_size_limit) {
        const ptr0 = passArray8ToWasm0$1(buffer, wasm$1.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN$1;
        const ret = wasm$1.tfhepublickey_safe_deserialize(ptr0, len0, serialized_size_limit);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfhePublicKey.__wrap(ret[0]);
    }
}

const TfheServerKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tfheserverkey_free(ptr >>> 0, 1));

class TfheServerKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TfheServerKey.prototype);
        obj.__wbg_ptr = ptr;
        TfheServerKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TfheServerKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tfheserverkey_free(ptr, 0);
    }
    /**
     * @param {TfheClientKey} client_key
     * @returns {TfheServerKey}
     */
    static new(client_key) {
        _assertClass$1(client_key, TfheClientKey);
        const ret = wasm$1.tfheserverkey_new(client_key.__wbg_ptr);
        if (ret[2]) {
            throw takeFromExternrefTable0$1(ret[1]);
        }
        return TfheServerKey.__wrap(ret[0]);
    }
}

const tfheFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_tfhe_free(ptr >>> 0, 1));

class tfhe {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        tfheFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_tfhe_free(ptr, 0);
    }
}

const wbg_rayon_PoolBuilderFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm$1.__wbg_wbg_rayon_poolbuilder_free(ptr >>> 0, 1));

class wbg_rayon_PoolBuilder {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(wbg_rayon_PoolBuilder.prototype);
        obj.__wbg_ptr = ptr;
        wbg_rayon_PoolBuilderFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        wbg_rayon_PoolBuilderFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm$1.__wbg_wbg_rayon_poolbuilder_free(ptr, 0);
    }
    /**
     * @returns {number}
     */
    numThreads() {
        const ret = wasm$1.wbg_rayon_poolbuilder_numThreads(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {number}
     */
    receiver() {
        const ret = wasm$1.wbg_rayon_poolbuilder_receiver(this.__wbg_ptr);
        return ret >>> 0;
    }
    build() {
        wasm$1.wbg_rayon_poolbuilder_build(this.__wbg_ptr);
    }
}

async function __wbg_load$1(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function __wbg_get_imports$1() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbg_BigInt_470dd987b8190f8e = function(arg0) {
        const ret = BigInt(arg0);
        return ret;
    };
    imports.wbg.__wbg_BigInt_ddea6d2f55558acb = function() { return handleError$1(function (arg0) {
        const ret = BigInt(arg0);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {
        const ret = arg0.buffer;
        return ret;
    };
    imports.wbg.__wbg_call_672a4d21634d4a24 = function() { return handleError$1(function (arg0, arg1) {
        const ret = arg0.call(arg1);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_call_7cccdd69e0791ae2 = function() { return handleError$1(function (arg0, arg1, arg2) {
        const ret = arg0.call(arg1, arg2);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_crypto_ed58b8e10a292839 = function(arg0) {
        const ret = arg0.crypto;
        return ret;
    };
    imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {
        let deferred0_0;
        let deferred0_1;
        try {
            deferred0_0 = arg0;
            deferred0_1 = arg1;
            console.error(getStringFromWasm0$1(arg0, arg1));
        } finally {
            wasm$1.__wbindgen_free(deferred0_0, deferred0_1, 1);
        }
    };
    imports.wbg.__wbg_getRandomValues_bcb4912f16000dc4 = function() { return handleError$1(function (arg0, arg1) {
        arg0.getRandomValues(arg1);
    }, arguments) };
    imports.wbg.__wbg_getTime_46267b1c24877e30 = function(arg0) {
        const ret = arg0.getTime();
        return ret;
    };
    imports.wbg.__wbg_instanceof_Window_def73ea0955fc569 = function(arg0) {
        let result;
        try {
            result = arg0 instanceof Window;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_msCrypto_0a36e2ec3a343d26 = function(arg0) {
        const ret = arg0.msCrypto;
        return ret;
    };
    imports.wbg.__wbg_new0_f788a2397c7ca929 = function() {
        const ret = new Date();
        return ret;
    };
    imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {
        const ret = new Error();
        return ret;
    };
    imports.wbg.__wbg_new_a12002a7f91c75be = function(arg0) {
        const ret = new Uint8Array(arg0);
        return ret;
    };
    imports.wbg.__wbg_newnoargs_105ed471475aaf50 = function(arg0, arg1) {
        const ret = new Function(getStringFromWasm0$1(arg0, arg1));
        return ret;
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a = function(arg0, arg1, arg2) {
        const ret = new Uint8Array(arg0, arg1 >>> 0, arg2 >>> 0);
        return ret;
    };
    imports.wbg.__wbg_newwithlength_a381634e90c276d4 = function(arg0) {
        const ret = new Uint8Array(arg0 >>> 0);
        return ret;
    };
    imports.wbg.__wbg_node_02999533c4ea02e3 = function(arg0) {
        const ret = arg0.node;
        return ret;
    };
    imports.wbg.__wbg_process_5c1d670bc53614b8 = function(arg0) {
        const ret = arg0.process;
        return ret;
    };
    imports.wbg.__wbg_randomFillSync_ab2cfe79ebbf2740 = function() { return handleError$1(function (arg0, arg1) {
        arg0.randomFillSync(arg1);
    }, arguments) };
    imports.wbg.__wbg_require_79b1e9274cde3c87 = function() { return handleError$1(function () {
        const ret = module.require;
        return ret;
    }, arguments) };
    imports.wbg.__wbg_set_65595bdd868b3009 = function(arg0, arg1, arg2) {
        arg0.set(arg1, arg2 >>> 0);
    };
    imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {
        const ret = arg1.stack;
        const ptr1 = passStringToWasm0$1(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN$1;
        getDataViewMemory0$1().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0$1().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbg_startWorkers_2ca11761e08ff5d5 = function(arg0, arg1, arg2) {
        const ret = startWorkers(arg0, arg1, wbg_rayon_PoolBuilder.__wrap(arg2));
        return ret;
    };
    imports.wbg.__wbg_static_accessor_GLOBAL_88a902d13a557d07 = function() {
        const ret = typeof global$1 === 'undefined' ? null : global$1;
        return isLikeNone$1(ret) ? 0 : addToExternrefTable0$1(ret);
    };
    imports.wbg.__wbg_static_accessor_GLOBAL_THIS_56578be7e9f832b0 = function() {
        const ret = typeof globalThis === 'undefined' ? null : globalThis;
        return isLikeNone$1(ret) ? 0 : addToExternrefTable0$1(ret);
    };
    imports.wbg.__wbg_static_accessor_SELF_37c5d418e4bf5819 = function() {
        const ret = typeof self === 'undefined' ? null : self;
        return isLikeNone$1(ret) ? 0 : addToExternrefTable0$1(ret);
    };
    imports.wbg.__wbg_static_accessor_WINDOW_5de37043a91a9c40 = function() {
        const ret = typeof window === 'undefined' ? null : window;
        return isLikeNone$1(ret) ? 0 : addToExternrefTable0$1(ret);
    };
    imports.wbg.__wbg_subarray_aa9065fa9dc5df96 = function(arg0, arg1, arg2) {
        const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
        return ret;
    };
    imports.wbg.__wbg_toString_2f76f493957b63da = function(arg0, arg1, arg2) {
        const ret = arg1.toString(arg2);
        const ptr1 = passStringToWasm0$1(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN$1;
        getDataViewMemory0$1().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0$1().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbg_toString_c813bbd34d063839 = function(arg0) {
        const ret = arg0.toString();
        return ret;
    };
    imports.wbg.__wbg_versions_c71aa1626a93e0a1 = function(arg0) {
        const ret = arg0.versions;
        return ret;
    };
    imports.wbg.__wbindgen_bigint_from_i128 = function(arg0, arg1) {
        const ret = arg0 << BigInt(64) | BigInt.asUintN(64, arg1);
        return ret;
    };
    imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {
        const ret = arg0;
        return ret;
    };
    imports.wbg.__wbindgen_bigint_from_str = function(arg0, arg1) {
        const ret = BigInt(getStringFromWasm0$1(arg0, arg1));
        return ret;
    };
    imports.wbg.__wbindgen_bigint_from_u128 = function(arg0, arg1) {
        const ret = BigInt.asUintN(64, arg0) << BigInt(64) | BigInt.asUintN(64, arg1);
        return ret;
    };
    imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {
        const ret = BigInt.asUintN(64, arg0);
        return ret;
    };
    imports.wbg.__wbindgen_bigint_get_as_i64 = function(arg0, arg1) {
        const v = arg1;
        const ret = typeof(v) === 'bigint' ? v : undefined;
        getDataViewMemory0$1().setBigInt64(arg0 + 8 * 1, isLikeNone$1(ret) ? BigInt(0) : ret, true);
        getDataViewMemory0$1().setInt32(arg0 + 4 * 0, !isLikeNone$1(ret), true);
    };
    imports.wbg.__wbindgen_bit_and = function(arg0, arg1) {
        const ret = arg0 & arg1;
        return ret;
    };
    imports.wbg.__wbindgen_bit_or = function(arg0, arg1) {
        const ret = arg0 | arg1;
        return ret;
    };
    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
        const ret = debugString$1(arg1);
        const ptr1 = passStringToWasm0$1(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN$1;
        getDataViewMemory0$1().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0$1().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
        const ret = new Error(getStringFromWasm0$1(arg0, arg1));
        return ret;
    };
    imports.wbg.__wbindgen_init_externref_table = function() {
        const table = wasm$1.__wbindgen_export_2;
        const offset = table.grow(4);
        table.set(0, undefined);
        table.set(offset + 0, undefined);
        table.set(offset + 1, null);
        table.set(offset + 2, true);
        table.set(offset + 3, false);
    };
    imports.wbg.__wbindgen_is_function = function(arg0) {
        const ret = typeof(arg0) === 'function';
        return ret;
    };
    imports.wbg.__wbindgen_is_object = function(arg0) {
        const val = arg0;
        const ret = typeof(val) === 'object' && val !== null;
        return ret;
    };
    imports.wbg.__wbindgen_is_string = function(arg0) {
        const ret = typeof(arg0) === 'string';
        return ret;
    };
    imports.wbg.__wbindgen_is_undefined = function(arg0) {
        const ret = arg0 === undefined;
        return ret;
    };
    imports.wbg.__wbindgen_jsval_eq = function(arg0, arg1) {
        const ret = arg0 === arg1;
        return ret;
    };
    imports.wbg.__wbindgen_lt = function(arg0, arg1) {
        const ret = arg0 < arg1;
        return ret;
    };
    imports.wbg.__wbindgen_memory = function() {
        const ret = wasm$1.memory;
        return ret;
    };
    imports.wbg.__wbindgen_module = function() {
        const ret = __wbg_init$1.__wbindgen_wasm_module;
        return ret;
    };
    imports.wbg.__wbindgen_neg = function(arg0) {
        const ret = -arg0;
        return ret;
    };
    imports.wbg.__wbindgen_number_new = function(arg0) {
        const ret = arg0;
        return ret;
    };
    imports.wbg.__wbindgen_shl = function(arg0, arg1) {
        const ret = arg0 << arg1;
        return ret;
    };
    imports.wbg.__wbindgen_shr = function(arg0, arg1) {
        const ret = arg0 >> arg1;
        return ret;
    };
    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
        const obj = arg1;
        const ret = typeof(obj) === 'string' ? obj : undefined;
        var ptr1 = isLikeNone$1(ret) ? 0 : passStringToWasm0$1(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN$1;
        getDataViewMemory0$1().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0$1().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
        const ret = getStringFromWasm0$1(arg0, arg1);
        return ret;
    };
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0$1(arg0, arg1));
    };

    return imports;
}

function __wbg_init_memory(imports, memory) {
    imports.wbg.memory = memory || new WebAssembly.Memory({initial:20,maximum:16384,shared:true});
}

function __wbg_finalize_init$1(instance, module, thread_stack_size) {
    wasm$1 = instance.exports;
    __wbg_init$1.__wbindgen_wasm_module = module;
    cachedDataViewMemory0$1 = null;
    cachedUint8ArrayMemory0$1 = null;

    if (typeof thread_stack_size !== 'undefined' && (typeof thread_stack_size !== 'number' || thread_stack_size === 0 || thread_stack_size % 65536 !== 0)) { throw 'invalid stack size' }
    wasm$1.__wbindgen_start(thread_stack_size);
    return wasm$1;
}

function initSync(module, memory) {
    if (wasm$1 !== undefined) return wasm$1;

    let thread_stack_size;
    if (typeof module !== 'undefined') {
        if (Object.getPrototypeOf(module) === Object.prototype) {
            ({module, memory, thread_stack_size} = module);
        } else {
            console.warn('using deprecated parameters for `initSync()`; pass a single object instead');
        }
    }

    const imports = __wbg_get_imports$1();

    __wbg_init_memory(imports, memory);

    if (!(module instanceof WebAssembly.Module)) {
        module = new WebAssembly.Module(module);
    }

    const instance = new WebAssembly.Instance(module, imports);

    return __wbg_finalize_init$1(instance, module, thread_stack_size);
}

async function __wbg_init$1(module_or_path, memory) {
    if (wasm$1 !== undefined) return wasm$1;

    let thread_stack_size;
    if (typeof module_or_path !== 'undefined') {
        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
            ({module_or_path, memory, thread_stack_size} = module_or_path);
        } else {
            console.warn('using deprecated parameters for the initialization function; pass a single object instead');
        }
    }

    if (typeof module_or_path === 'undefined') {
        module_or_path = new URL('tfhe_bg.wasm', import.meta.url);
    }
    const imports = __wbg_get_imports$1();

    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {
        module_or_path = fetch(module_or_path);
    }

    __wbg_init_memory(imports, memory);

    const { instance, module } = await __wbg_load$1(await module_or_path, imports);

    return __wbg_finalize_init$1(instance, module, thread_stack_size);
}

var tfhe$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Boolean: Boolean,
  BooleanCiphertext: BooleanCiphertext,
  BooleanClientKey: BooleanClientKey,
  BooleanCompressedCiphertext: BooleanCompressedCiphertext,
  BooleanCompressedServerKey: BooleanCompressedServerKey,
  BooleanEncryptionKeyChoice: BooleanEncryptionKeyChoice,
  BooleanNoiseDistribution: BooleanNoiseDistribution,
  BooleanParameterSet: BooleanParameterSet,
  BooleanParameters: BooleanParameters,
  BooleanPublicKey: BooleanPublicKey,
  CompactCiphertextList: CompactCiphertextList,
  CompactCiphertextListBuilder: CompactCiphertextListBuilder,
  CompactCiphertextListExpander: CompactCiphertextListExpander,
  CompactPkeCrs: CompactPkeCrs,
  CompressedFheBool: CompressedFheBool,
  CompressedFheInt10: CompressedFheInt10,
  CompressedFheInt12: CompressedFheInt12,
  CompressedFheInt128: CompressedFheInt128,
  CompressedFheInt14: CompressedFheInt14,
  CompressedFheInt16: CompressedFheInt16,
  CompressedFheInt160: CompressedFheInt160,
  CompressedFheInt2: CompressedFheInt2,
  CompressedFheInt256: CompressedFheInt256,
  CompressedFheInt32: CompressedFheInt32,
  CompressedFheInt4: CompressedFheInt4,
  CompressedFheInt6: CompressedFheInt6,
  CompressedFheInt64: CompressedFheInt64,
  CompressedFheInt8: CompressedFheInt8,
  CompressedFheUint10: CompressedFheUint10,
  CompressedFheUint1024: CompressedFheUint1024,
  CompressedFheUint12: CompressedFheUint12,
  CompressedFheUint128: CompressedFheUint128,
  CompressedFheUint14: CompressedFheUint14,
  CompressedFheUint16: CompressedFheUint16,
  CompressedFheUint160: CompressedFheUint160,
  CompressedFheUint2: CompressedFheUint2,
  CompressedFheUint2048: CompressedFheUint2048,
  CompressedFheUint256: CompressedFheUint256,
  CompressedFheUint32: CompressedFheUint32,
  CompressedFheUint4: CompressedFheUint4,
  CompressedFheUint512: CompressedFheUint512,
  CompressedFheUint6: CompressedFheUint6,
  CompressedFheUint64: CompressedFheUint64,
  CompressedFheUint8: CompressedFheUint8,
  FheBool: FheBool,
  FheInt10: FheInt10,
  FheInt12: FheInt12,
  FheInt128: FheInt128,
  FheInt14: FheInt14,
  FheInt16: FheInt16,
  FheInt160: FheInt160,
  FheInt2: FheInt2,
  FheInt256: FheInt256,
  FheInt32: FheInt32,
  FheInt4: FheInt4,
  FheInt6: FheInt6,
  FheInt64: FheInt64,
  FheInt8: FheInt8,
  FheTypes: FheTypes,
  FheUint10: FheUint10,
  FheUint1024: FheUint1024,
  FheUint12: FheUint12,
  FheUint128: FheUint128,
  FheUint14: FheUint14,
  FheUint16: FheUint16,
  FheUint160: FheUint160,
  FheUint2: FheUint2,
  FheUint2048: FheUint2048,
  FheUint256: FheUint256,
  FheUint32: FheUint32,
  FheUint4: FheUint4,
  FheUint512: FheUint512,
  FheUint6: FheUint6,
  FheUint64: FheUint64,
  FheUint8: FheUint8,
  ProvenCompactCiphertextList: ProvenCompactCiphertextList,
  Shortint: Shortint,
  ShortintCiphertext: ShortintCiphertext,
  ShortintClientKey: ShortintClientKey,
  ShortintCompactPublicKeyEncryptionParameters: ShortintCompactPublicKeyEncryptionParameters,
  ShortintCompactPublicKeyEncryptionParametersName: ShortintCompactPublicKeyEncryptionParametersName,
  ShortintCompressedCiphertext: ShortintCompressedCiphertext,
  ShortintCompressedPublicKey: ShortintCompressedPublicKey,
  ShortintCompressedServerKey: ShortintCompressedServerKey,
  ShortintEncryptionKeyChoice: ShortintEncryptionKeyChoice,
  ShortintNoiseDistribution: ShortintNoiseDistribution,
  ShortintPBSOrder: ShortintPBSOrder,
  ShortintParameters: ShortintParameters,
  ShortintParametersName: ShortintParametersName,
  ShortintPublicKey: ShortintPublicKey,
  TfheClientKey: TfheClientKey,
  TfheCompactPublicKey: TfheCompactPublicKey,
  TfheCompressedCompactPublicKey: TfheCompressedCompactPublicKey,
  TfheCompressedPublicKey: TfheCompressedPublicKey,
  TfheCompressedServerKey: TfheCompressedServerKey,
  TfheConfig: TfheConfig,
  TfheConfigBuilder: TfheConfigBuilder,
  TfhePublicKey: TfhePublicKey,
  TfheServerKey: TfheServerKey,
  ZkComputeLoad: ZkComputeLoad,
  default: __wbg_init$1,
  initSync: initSync,
  initThreadPool: initThreadPool,
  init_panic_hook: init_panic_hook,
  set_server_key: set_server_key,
  shortint_params_name: shortint_params_name,
  shortint_pke_params_name: shortint_pke_params_name,
  tfhe: tfhe,
  wbg_rayon_PoolBuilder: wbg_rayon_PoolBuilder,
  wbg_rayon_start_worker: wbg_rayon_start_worker
});

const SERIALIZED_SIZE_LIMIT_CIPHERTEXT = BigInt(1024 * 1024 * 512);
const SERIALIZED_SIZE_LIMIT_PK = BigInt(1024 * 1024 * 512);
const SERIALIZED_SIZE_LIMIT_CRS = BigInt(1024 * 1024 * 512);
const cleanURL = (url) => {
    if (!url)
        return '';
    return new URL(url).href;
};
const numberToHex = (num) => {
    let hex = num.toString(16);
    return hex.length % 2 ? '0' + hex : hex;
};
const fromHexString = (hexString) => {
    const arr = hexString.replace(/^(0x)/, '').match(/.{1,2}/g);
    if (!arr)
        return new Uint8Array();
    return Uint8Array.from(arr.map((byte) => parseInt(byte, 16)));
};
const toHexString = (bytes, with0x = false) => `${with0x ? '0x' : ''}${bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '')}`;
const bytesToBigInt = function (byteArray) {
    if (!byteArray || byteArray?.length === 0) {
        return BigInt(0);
    }
    const buffer = Buffer.from(byteArray);
    const result = toBigIntBE(buffer);
    return result;
};

const keyurlCache = {};
const getKeysFromRelayer = async (url, publicKeyId) => {
    if (keyurlCache[url]) {
        return keyurlCache[url];
    }
    try {
        const response = await fetch(`${url}v1/keyurl`);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        if (data) {
            let pubKeyUrl;
            // If no publicKeyId is provided, use the first one
            // Warning: if there are multiple keys available, the first one will most likely never be the
            // same between several calls (fetching the infos is non-deterministic)
            if (!publicKeyId) {
                pubKeyUrl = data.response.fhe_key_info[0].fhe_public_key.urls[0];
                publicKeyId = data.response.fhe_key_info[0].fhe_public_key.data_id;
            }
            else {
                // If a publicKeyId is provided, get the corresponding info
                const keyInfo = data.response.fhe_key_info.find((info) => info.fhe_public_key.data_id === publicKeyId);
                if (!keyInfo) {
                    throw new Error(`Could not find FHE key info with data_id ${publicKeyId}`);
                }
                // TODO: Get a given party's public key url instead of the first one
                pubKeyUrl = keyInfo.fhe_public_key.urls[0];
            }
            const publicKeyResponse = await fetch(pubKeyUrl);
            if (!publicKeyResponse.ok) {
                throw new Error(`HTTP error! status: ${publicKeyResponse.status} on ${publicKeyResponse.url}`);
            }
            const publicKey = await publicKeyResponse.bytes();
            const publicParamsUrl = data.response.crs['2048'].urls[0];
            const publicParamsId = data.response.crs['2048'].data_id;
            const publicParams2048Response = await fetch(publicParamsUrl);
            if (!publicParams2048Response.ok) {
                throw new Error(`HTTP error! status: ${publicParams2048Response.status} on ${publicParams2048Response.url}`);
            }
            const publicParams2048 = await publicParams2048Response.bytes();
            let pub_key;
            try {
                pub_key = TfheCompactPublicKey.safe_deserialize(publicKey, SERIALIZED_SIZE_LIMIT_PK);
            }
            catch (e) {
                throw new Error('Invalid public key (deserialization failed)', {
                    cause: e,
                });
            }
            let crs;
            try {
                crs = CompactPkeCrs.safe_deserialize(new Uint8Array(publicParams2048), SERIALIZED_SIZE_LIMIT_CRS);
            }
            catch (e) {
                throw new Error('Invalid crs (deserialization failed)', {
                    cause: e,
                });
            }
            const result = {
                publicKey: pub_key,
                publicKeyId,
                publicParams: {
                    2048: {
                        publicParams: crs,
                        publicParamsId,
                    },
                },
            };
            keyurlCache[url] = result;
            return result;
        }
        else {
            throw new Error('No public key available');
        }
    }
    catch (e) {
        throw new Error('Impossible to fetch public key: wrong relayer url.', {
            cause: e,
        });
    }
};

const abiKmsVerifier = ['function getKmsSigners() view returns (address[])'];
const getProvider = (config) => {
    if (typeof config.network === 'string') {
        return new JsonRpcProvider(config.network);
    }
    else if (config.network) {
        return new BrowserProvider(config.network);
    }
    throw new Error('You must provide a network URL or a EIP1193 object (eg: window.ethereum)');
};
const getChainId = async (provider, config) => {
    if (config.chainId && typeof config.chainId === 'number') {
        return config.chainId;
    }
    else if (config.chainId && typeof config.chainId !== 'number') {
        throw new Error('chainId must be a number.');
    }
    else {
        const chainId = (await provider.getNetwork()).chainId;
        return Number(chainId);
    }
};
const getTfheCompactPublicKey = async (config) => {
    if (config.relayerUrl && !config.publicKey) {
        const inputs = await getKeysFromRelayer(cleanURL(config.relayerUrl));
        return { publicKey: inputs.publicKey, publicKeyId: inputs.publicKeyId };
    }
    else if (config.publicKey && config.publicKey.data && config.publicKey.id) {
        const buff = config.publicKey.data;
        try {
            return {
                publicKey: TfheCompactPublicKey.safe_deserialize(buff, SERIALIZED_SIZE_LIMIT_PK),
                publicKeyId: config.publicKey.id,
            };
        }
        catch (e) {
            throw new Error('Invalid public key (deserialization failed)', {
                cause: e,
            });
        }
    }
    else {
        throw new Error('You must provide a public key with its public key ID.');
    }
};
const getPublicParams = async (config) => {
    if (config.relayerUrl && !config.publicParams) {
        const inputs = await getKeysFromRelayer(cleanURL(config.relayerUrl));
        return inputs.publicParams;
    }
    else if (config.publicParams && config.publicParams['2048']) {
        const buff = config.publicParams['2048'].publicParams;
        try {
            return {
                2048: {
                    publicParams: CompactPkeCrs.safe_deserialize(buff, SERIALIZED_SIZE_LIMIT_CRS),
                    publicParamsId: config.publicParams['2048'].publicParamsId,
                },
            };
        }
        catch (e) {
            throw new Error('Invalid public key (deserialization failed)', {
                cause: e,
            });
        }
    }
    else {
        throw new Error('You must provide a valid CRS with its CRS ID.');
    }
};
const getKMSSigners = async (provider, config) => {
    const kmsContract = new Contract(config.kmsContractAddress, abiKmsVerifier, provider);
    const signers = await kmsContract.getKmsSigners();
    return signers;
};

let wasm;

let WASM_VECTOR_LEN = 0;

let cachedUint8ArrayMemory0 = null;

function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
}

const cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length, 1) >>> 0;
        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;

    const mem = getUint8ArrayMemory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

let cachedDataViewMemory0 = null;

function getDataViewMemory0() {
    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {
        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
    }
    return cachedDataViewMemory0;
}

function addToExternrefTable0(obj) {
    const idx = wasm.__externref_table_alloc();
    wasm.__wbindgen_export_4.set(idx, obj);
    return idx;
}

function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        const idx = addToExternrefTable0(e);
        wasm.__wbindgen_exn_store(idx);
    }
}

const cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); }
function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches && builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
}

function getArrayU8FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}

function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1, 1) >>> 0;
    getUint8ArrayMemory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}

function takeFromExternrefTable0(idx) {
    const value = wasm.__wbindgen_export_4.get(idx);
    wasm.__externref_table_dealloc(idx);
    return value;
}

function passArrayJsValueToWasm0(array, malloc) {
    const ptr = malloc(array.length * 4, 4) >>> 0;
    const mem = getDataViewMemory0();
    for (let i = 0; i < array.length; i++) {
        mem.setUint32(ptr + 4 * i, addToExternrefTable0(array[i]), true);
    }
    WASM_VECTOR_LEN = array.length;
    return ptr;
}
/**
 * Instantiate a new client.
 *
 * * `server_addrs` - a list of KMS server EIP-55 addresses,
 * must be prefixed with "0x".
 *
 * * `client_address_hex` - the client (wallet) address in hex,
 * must be prefixed with "0x".
 *
 * * `fhe_parameter` - the parameter choice, which can be either `"test"` or `"default"`.
 * The "default" parameter choice is selected if no matching string is found.
 * @param {(string)[]} server_addrs
 * @param {string} client_address_hex
 * @param {string} fhe_parameter
 * @returns {Client}
 */
function new_client(server_addrs, client_address_hex, fhe_parameter) {
    const ptr0 = passArrayJsValueToWasm0(server_addrs, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(client_address_hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    const ptr2 = passStringToWasm0(fhe_parameter, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len2 = WASM_VECTOR_LEN;
    const ret = wasm.new_client(ptr0, len0, ptr1, len1, ptr2, len2);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return Client.__wrap(ret[0]);
}

function getArrayJsValueFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    const mem = getDataViewMemory0();
    const result = [];
    for (let i = ptr; i < ptr + 4 * len; i += 4) {
        result.push(wasm.__wbindgen_export_4.get(mem.getUint32(i, true)));
    }
    wasm.__externref_drop_slice(ptr, len);
    return result;
}

/**
 * @returns {PrivateEncKey}
 */
function cryptobox_keygen() {
    const ret = wasm.cryptobox_keygen();
    return PrivateEncKey.__wrap(ret);
}

/**
 * @param {PrivateEncKey} sk
 * @returns {PublicEncKey}
 */
function cryptobox_get_pk(sk) {
    _assertClass(sk, PrivateEncKey);
    const ret = wasm.cryptobox_get_pk(sk.__wbg_ptr);
    return PublicEncKey.__wrap(ret);
}

/**
 * @param {PublicEncKey} pk
 * @returns {Uint8Array}
 */
function cryptobox_pk_to_u8vec(pk) {
    _assertClass(pk, PublicEncKey);
    const ret = wasm.cryptobox_pk_to_u8vec(pk.__wbg_ptr);
    if (ret[3]) {
        throw takeFromExternrefTable0(ret[2]);
    }
    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    return v1;
}

/**
 * @param {PrivateEncKey} sk
 * @returns {Uint8Array}
 */
function cryptobox_sk_to_u8vec(sk) {
    _assertClass(sk, PrivateEncKey);
    const ret = wasm.cryptobox_sk_to_u8vec(sk.__wbg_ptr);
    if (ret[3]) {
        throw takeFromExternrefTable0(ret[2]);
    }
    var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
    return v1;
}

/**
 * @param {Uint8Array} v
 * @returns {PublicEncKey}
 */
function u8vec_to_cryptobox_pk(v) {
    const ptr0 = passArray8ToWasm0(v, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.u8vec_to_cryptobox_pk(ptr0, len0);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return PublicEncKey.__wrap(ret[0]);
}

/**
 * @param {Uint8Array} v
 * @returns {PrivateEncKey}
 */
function u8vec_to_cryptobox_sk(v) {
    const ptr0 = passArray8ToWasm0(v, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.u8vec_to_cryptobox_sk(ptr0, len0);
    if (ret[2]) {
        throw takeFromExternrefTable0(ret[1]);
    }
    return PrivateEncKey.__wrap(ret[0]);
}

/**
 * Process the reencryption response from JavaScript objects.
 * The returned result is a byte array representing a plaintext of any length,
 * postprocessing is returned to turn it into an integer.
 *
 * * `client` - client that wants to perform reencryption.
 *
 * * `request` - the initial reencryption request JS object.
 * It can be set to null if `verify` is false.
 * Otherwise the caller needs to give the following JS object.
 * Note that `client_address` and `eip712_verifying_contract` follow EIP-55.
 * The signature field is not needed.
 * ```
 * {
 *   signature: undefined,
 *   client_address: '0x17853A630aAe15AED549B2B874de08B73C0F59c5',
 *   enc_key: '2000000000000000df2fcacb774f03187f3802a27259f45c06d33cefa68d9c53426b15ad531aa822',
 *   ciphertext_handles: [ '0748b542afe2353c86cb707e3d21044b0be1fd18efc7cbaa6a415af055bfb358' ]
 *   eip712_verifying_contract: '0x66f9664f97F2b50F62D13eA064982f936dE76657'
 * }
 * ```
 *
 * * `eip712_domain` - the EIP-712 domain JS object.
 * It can be set to null if `verify` is false.
 * Otherwise the caller needs to give the following JS object.
 * Note that `salt` is optional and `verifying_contract` follows EIP-55,
 * additionally, `chain_id` is an array of u8.
 * ```
 * {
 *   name: 'Authorization token',
 *   version: '1',
 *   chain_id: [
 *     70, 31, 0, 0, 0, 0, 0, 0, 0,
 *      0,  0, 0, 0, 0, 0, 0, 0, 0,
 *      0,  0, 0, 0, 0, 0, 0, 0, 0,
 *      0,  0, 0, 0, 0
 *   ],
 *   verifying_contract: '0x66f9664f97F2b50F62D13eA064982f936dE76657',
 *   salt: []
 * }
 * ```
 *
 * * `agg_resp` - the response JS object from the gateway.
 * It has two fields like so, both are hex encoded byte arrays.
 * ```
 * [
 *   {
 *     signature: '69e7e040cab157aa819015b321c012dccb1545ffefd325b359b492653f0347517e28e66c572cdc299e259024329859ff9fcb0096e1ce072af0b6e1ca1fe25ec6',
 *     payload: '0100000029...'
 *   }
 * ]
 * ```
 *
 * * `enc_pk` - The ephemeral public key.
 *
 * * `enc_sk` - The ephemeral secret key.
 *
 * * `verify` - Whether to perform signature verification for the response.
 * It is insecure if `verify = false`!
 * @param {Client} client
 * @param {any} request
 * @param {any} eip712_domain
 * @param {any} agg_resp
 * @param {PublicEncKey} enc_pk
 * @param {PrivateEncKey} enc_sk
 * @param {boolean} verify
 * @returns {(TypedPlaintext)[]}
 */
function process_reencryption_resp_from_js(client, request, eip712_domain, agg_resp, enc_pk, enc_sk, verify) {
    _assertClass(client, Client);
    _assertClass(enc_pk, PublicEncKey);
    _assertClass(enc_sk, PrivateEncKey);
    const ret = wasm.process_reencryption_resp_from_js(client.__wbg_ptr, request, eip712_domain, agg_resp, enc_pk.__wbg_ptr, enc_sk.__wbg_ptr, verify);
    if (ret[3]) {
        throw takeFromExternrefTable0(ret[2]);
    }
    var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
    return v1;
}

(typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_ciphertexthandle_free(ptr >>> 0, 1));

const ClientFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_client_free(ptr >>> 0, 1));
/**
 * Core Client
 *
 * Simple client to interact with the KMS servers. This can be seen as a proof-of-concept
 * and reference code for validating the KMS. The logic supplied by the client will be
 * distributed across the aggregator/proxy and smart contracts.
 */
class Client {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(Client.prototype);
        obj.__wbg_ptr = ptr;
        ClientFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ClientFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_client_free(ptr, 0);
    }
}

(typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_cryptoboxct_free(ptr >>> 0, 1));

(typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_eip712domainmsg_free(ptr >>> 0, 1));

(typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_parsedreencryptionrequest_free(ptr >>> 0, 1));

const PrivateEncKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_privateenckey_free(ptr >>> 0, 1));

class PrivateEncKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PrivateEncKey.prototype);
        obj.__wbg_ptr = ptr;
        PrivateEncKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PrivateEncKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_privateenckey_free(ptr, 0);
    }
}

(typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_privatesigkey_free(ptr >>> 0, 1));

const PublicEncKeyFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_publicenckey_free(ptr >>> 0, 1));

class PublicEncKey {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(PublicEncKey.prototype);
        obj.__wbg_ptr = ptr;
        PublicEncKeyFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        PublicEncKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_publicenckey_free(ptr, 0);
    }
}

(typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_publicsigkey_free(ptr >>> 0, 1));

(typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_reencryptionrequest_free(ptr >>> 0, 1));

const ReencryptionResponseFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_reencryptionresponse_free(ptr >>> 0, 1));

class ReencryptionResponse {

    static __unwrap(jsValue) {
        if (!(jsValue instanceof ReencryptionResponse)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ReencryptionResponseFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_reencryptionresponse_free(ptr, 0);
    }
    /**
     * @returns {Uint8Array}
     */
    get signature() {
        const ret = wasm.__wbg_get_reencryptionresponse_signature(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * @param {Uint8Array} arg0
     */
    set signature(arg0) {
        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * This is the external signature created from the Eip712 domain
     * on the structure, where reencryptedShare is bincode::serialize(&payload)
     * struct UserDecryptResponseVerification {
     *      bytes publicKey;
     *      uint256\[\] ctHandles;
     *      bytes reencryptedShare;
     * }
     * @returns {Uint8Array}
     */
    get external_signature() {
        const ret = wasm.__wbg_get_reencryptionresponse_external_signature(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * This is the external signature created from the Eip712 domain
     * on the structure, where reencryptedShare is bincode::serialize(&payload)
     * struct UserDecryptResponseVerification {
     *      bytes publicKey;
     *      uint256\[\] ctHandles;
     *      bytes reencryptedShare;
     * }
     * @param {Uint8Array} arg0
     */
    set external_signature(arg0) {
        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The actual \[ReencryptionResponsePayload\].
     * @returns {ReencryptionResponsePayload | undefined}
     */
    get payload() {
        const ret = wasm.__wbg_get_reencryptionresponse_payload(this.__wbg_ptr);
        return ret === 0 ? undefined : ReencryptionResponsePayload.__wrap(ret);
    }
    /**
     * The actual \[ReencryptionResponsePayload\].
     * @param {ReencryptionResponsePayload | undefined} [arg0]
     */
    set payload(arg0) {
        let ptr0 = 0;
        if (!isLikeNone(arg0)) {
            _assertClass(arg0, ReencryptionResponsePayload);
            ptr0 = arg0.__destroy_into_raw();
        }
        wasm.__wbg_set_reencryptionresponse_payload(this.__wbg_ptr, ptr0);
    }
}

const ReencryptionResponsePayloadFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_reencryptionresponsepayload_free(ptr >>> 0, 1));

class ReencryptionResponsePayload {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(ReencryptionResponsePayload.prototype);
        obj.__wbg_ptr = ptr;
        ReencryptionResponsePayloadFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        ReencryptionResponsePayloadFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_reencryptionresponsepayload_free(ptr, 0);
    }
    /**
     * The server's signature verification key, Encoded using SEC1.
     * Needed to validate the response, but MUST also be linked to a list of
     * trusted keys.
     * @returns {Uint8Array}
     */
    get verification_key() {
        const ret = wasm.__wbg_get_reencryptionresponsepayload_verification_key(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * The server's signature verification key, Encoded using SEC1.
     * Needed to validate the response, but MUST also be linked to a list of
     * trusted keys.
     * @param {Uint8Array} arg0
     */
    set verification_key(arg0) {
        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * This is needed to ensure the response corresponds to the request.
     * It is the digest of UserDecryptionLinker hashed using EIP712
     * under the given domain in the request.
     * @returns {Uint8Array}
     */
    get digest() {
        const ret = wasm.__wbg_get_reencryptionresponsepayload_digest(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * This is needed to ensure the response corresponds to the request.
     * It is the digest of UserDecryptionLinker hashed using EIP712
     * under the given domain in the request.
     * @param {Uint8Array} arg0
     */
    set digest(arg0) {
        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The resulting signcrypted ciphertexts, each ciphertext
     * must be decrypted and then reconstructed with the other shares
     * to produce the final plaintext.
     * @returns {(TypedSigncryptedCiphertext)[]}
     */
    get signcrypted_ciphertexts() {
        const ret = wasm.__wbg_get_reencryptionresponsepayload_signcrypted_ciphertexts(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * The resulting signcrypted ciphertexts, each ciphertext
     * must be decrypted and then reconstructed with the other shares
     * to produce the final plaintext.
     * @param {(TypedSigncryptedCiphertext)[]} arg0
     */
    set signcrypted_ciphertexts(arg0) {
        const ptr0 = passArrayJsValueToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_reencryptionresponsepayload_signcrypted_ciphertexts(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The ID of the MPC party doing the reencryption. Used for polynomial
     * reconstruction.
     * @returns {number}
     */
    get party_id() {
        const ret = wasm.__wbg_get_reencryptionresponsepayload_party_id(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * The ID of the MPC party doing the reencryption. Used for polynomial
     * reconstruction.
     * @param {number} arg0
     */
    set party_id(arg0) {
        wasm.__wbg_set_reencryptionresponsepayload_party_id(this.__wbg_ptr, arg0);
    }
    /**
     * The degree of the sharing scheme used.
     * @returns {number}
     */
    get degree() {
        const ret = wasm.__wbg_get_reencryptionresponsepayload_degree(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * The degree of the sharing scheme used.
     * @param {number} arg0
     */
    set degree(arg0) {
        wasm.__wbg_set_reencryptionresponsepayload_degree(this.__wbg_ptr, arg0);
    }
}

(typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_requestid_free(ptr >>> 0, 1));

const TypedCiphertextFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_typedciphertext_free(ptr >>> 0, 1));

class TypedCiphertext {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TypedCiphertext.prototype);
        obj.__wbg_ptr = ptr;
        TypedCiphertextFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof TypedCiphertext)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TypedCiphertextFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_typedciphertext_free(ptr, 0);
    }
    /**
     * The actual ciphertext to decrypt, taken directly from HTTPZ.
     * @returns {Uint8Array}
     */
    get ciphertext() {
        const ret = wasm.__wbg_get_typedciphertext_ciphertext(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * The actual ciphertext to decrypt, taken directly from HTTPZ.
     * @param {Uint8Array} arg0
     */
    set ciphertext(arg0) {
        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The type of plaintext encrypted.
     * @returns {number}
     */
    get fhe_type() {
        const ret = wasm.__wbg_get_typedciphertext_fhe_type(this.__wbg_ptr);
        return ret;
    }
    /**
     * The type of plaintext encrypted.
     * @param {number} arg0
     */
    set fhe_type(arg0) {
        wasm.__wbg_set_typedciphertext_fhe_type(this.__wbg_ptr, arg0);
    }
    /**
     * The external handle of the ciphertext (the handle used in the copro).
     * @returns {Uint8Array}
     */
    get external_handle() {
        const ret = wasm.__wbg_get_typedciphertext_external_handle(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * The external handle of the ciphertext (the handle used in the copro).
     * @param {Uint8Array} arg0
     */
    set external_handle(arg0) {
        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The ciphertext format, see CiphertextFormat documentation for details.
     * CiphertextFormat::default() is used if unspecified.
     * @returns {number}
     */
    get ciphertext_format() {
        const ret = wasm.__wbg_get_typedciphertext_ciphertext_format(this.__wbg_ptr);
        return ret;
    }
    /**
     * The ciphertext format, see CiphertextFormat documentation for details.
     * CiphertextFormat::default() is used if unspecified.
     * @param {number} arg0
     */
    set ciphertext_format(arg0) {
        wasm.__wbg_set_typedciphertext_ciphertext_format(this.__wbg_ptr, arg0);
    }
}

const TypedPlaintextFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_typedplaintext_free(ptr >>> 0, 1));
/**
 * The typed plaintext type, which is the result of decryption.
 */
class TypedPlaintext {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TypedPlaintext.prototype);
        obj.__wbg_ptr = ptr;
        TypedPlaintextFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TypedPlaintextFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_typedplaintext_free(ptr, 0);
    }
    /**
     * The actual plaintext in bytes.
     * @returns {Uint8Array}
     */
    get bytes() {
        const ret = wasm.__wbg_get_typedplaintext_bytes(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * The actual plaintext in bytes.
     * @param {Uint8Array} arg0
     */
    set bytes(arg0) {
        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The type of plaintext encrypted.
     * @returns {number}
     */
    get fhe_type() {
        const ret = wasm.__wbg_get_typedplaintext_fhe_type(this.__wbg_ptr);
        return ret;
    }
    /**
     * The type of plaintext encrypted.
     * @param {number} arg0
     */
    set fhe_type(arg0) {
        wasm.__wbg_set_typedplaintext_fhe_type(this.__wbg_ptr, arg0);
    }
}

const TypedSigncryptedCiphertextFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_typedsigncryptedciphertext_free(ptr >>> 0, 1));

class TypedSigncryptedCiphertext {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(TypedSigncryptedCiphertext.prototype);
        obj.__wbg_ptr = ptr;
        TypedSigncryptedCiphertextFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof TypedSigncryptedCiphertext)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        TypedSigncryptedCiphertextFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_typedsigncryptedciphertext_free(ptr, 0);
    }
    /**
     * The type of plaintext encrypted.
     * @returns {number}
     */
    get fhe_type() {
        const ret = wasm.__wbg_get_typedciphertext_fhe_type(this.__wbg_ptr);
        return ret;
    }
    /**
     * The type of plaintext encrypted.
     * @param {number} arg0
     */
    set fhe_type(arg0) {
        wasm.__wbg_set_typedciphertext_fhe_type(this.__wbg_ptr, arg0);
    }
    /**
     * The signcrypted payload, using a hybrid encryption approach in
     * sign-then-encrypt.
     * @returns {Uint8Array}
     */
    get signcrypted_ciphertext() {
        const ret = wasm.__wbg_get_typedsigncryptedciphertext_signcrypted_ciphertext(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * The signcrypted payload, using a hybrid encryption approach in
     * sign-then-encrypt.
     * @param {Uint8Array} arg0
     */
    set signcrypted_ciphertext(arg0) {
        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_eip712domainmsg_name(this.__wbg_ptr, ptr0, len0);
    }
    /**
     * The external handles that were originally in the request.
     * @returns {Uint8Array}
     */
    get external_handle() {
        const ret = wasm.__wbg_get_typedsigncryptedciphertext_external_handle(this.__wbg_ptr);
        var v1 = getArrayU8FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        return v1;
    }
    /**
     * The external handles that were originally in the request.
     * @param {Uint8Array} arg0
     */
    set external_handle(arg0) {
        const ptr0 = passArray8ToWasm0(arg0, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.__wbg_set_eip712domainmsg_version(this.__wbg_ptr, ptr0, len0);
    }
}

async function __wbg_load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbg_String_8f0eb39a4a4c2f66 = function(arg0, arg1) {
        const ret = String(arg1);
        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbg_buffer_61b7ce01341d7f88 = function(arg0) {
        const ret = arg0.buffer;
        return ret;
    };
    imports.wbg.__wbg_call_500db948e69c7330 = function() { return handleError(function (arg0, arg1, arg2) {
        const ret = arg0.call(arg1, arg2);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_call_b0d8e36992d9900d = function() { return handleError(function (arg0, arg1) {
        const ret = arg0.call(arg1);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_crypto_ed58b8e10a292839 = function(arg0) {
        const ret = arg0.crypto;
        return ret;
    };
    imports.wbg.__wbg_done_f22c1561fa919baa = function(arg0) {
        const ret = arg0.done;
        return ret;
    };
    imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {
        let deferred0_0;
        let deferred0_1;
        try {
            deferred0_0 = arg0;
            deferred0_1 = arg1;
            console.error(getStringFromWasm0(arg0, arg1));
        } finally {
            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
        }
    };
    imports.wbg.__wbg_getRandomValues_bcb4912f16000dc4 = function() { return handleError(function (arg0, arg1) {
        arg0.getRandomValues(arg1);
    }, arguments) };
    imports.wbg.__wbg_get_9aa3dff3f0266054 = function(arg0, arg1) {
        const ret = arg0[arg1 >>> 0];
        return ret;
    };
    imports.wbg.__wbg_get_bbccf8970793c087 = function() { return handleError(function (arg0, arg1) {
        const ret = Reflect.get(arg0, arg1);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_getwithrefkey_1dc361bd10053bfe = function(arg0, arg1) {
        const ret = arg0[arg1];
        return ret;
    };
    imports.wbg.__wbg_instanceof_ArrayBuffer_670ddde44cdb2602 = function(arg0) {
        let result;
        try {
            result = arg0 instanceof ArrayBuffer;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_instanceof_Uint8Array_28af5bc19d6acad8 = function(arg0) {
        let result;
        try {
            result = arg0 instanceof Uint8Array;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_isArray_1ba11a930108ec51 = function(arg0) {
        const ret = Array.isArray(arg0);
        return ret;
    };
    imports.wbg.__wbg_isSafeInteger_12f5549b2fca23f4 = function(arg0) {
        const ret = Number.isSafeInteger(arg0);
        return ret;
    };
    imports.wbg.__wbg_iterator_23604bb983791576 = function() {
        const ret = Symbol.iterator;
        return ret;
    };
    imports.wbg.__wbg_length_65d1cd11729ced11 = function(arg0) {
        const ret = arg0.length;
        return ret;
    };
    imports.wbg.__wbg_length_d65cf0786bfc5739 = function(arg0) {
        const ret = arg0.length;
        return ret;
    };
    imports.wbg.__wbg_msCrypto_0a36e2ec3a343d26 = function(arg0) {
        const ret = arg0.msCrypto;
        return ret;
    };
    imports.wbg.__wbg_new_3ff5b33b1ce712df = function(arg0) {
        const ret = new Uint8Array(arg0);
        return ret;
    };
    imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {
        const ret = new Error();
        return ret;
    };
    imports.wbg.__wbg_newnoargs_fd9e4bf8be2bc16d = function(arg0, arg1) {
        const ret = new Function(getStringFromWasm0(arg0, arg1));
        return ret;
    };
    imports.wbg.__wbg_newwithbyteoffsetandlength_ba35896968751d91 = function(arg0, arg1, arg2) {
        const ret = new Uint8Array(arg0, arg1 >>> 0, arg2 >>> 0);
        return ret;
    };
    imports.wbg.__wbg_newwithlength_34ce8f1051e74449 = function(arg0) {
        const ret = new Uint8Array(arg0 >>> 0);
        return ret;
    };
    imports.wbg.__wbg_next_01dd9234a5bf6d05 = function() { return handleError(function (arg0) {
        const ret = arg0.next();
        return ret;
    }, arguments) };
    imports.wbg.__wbg_next_137428deb98342b0 = function(arg0) {
        const ret = arg0.next;
        return ret;
    };
    imports.wbg.__wbg_node_02999533c4ea02e3 = function(arg0) {
        const ret = arg0.node;
        return ret;
    };
    imports.wbg.__wbg_process_5c1d670bc53614b8 = function(arg0) {
        const ret = arg0.process;
        return ret;
    };
    imports.wbg.__wbg_randomFillSync_ab2cfe79ebbf2740 = function() { return handleError(function (arg0, arg1) {
        arg0.randomFillSync(arg1);
    }, arguments) };
    imports.wbg.__wbg_reencryptionresponse_unwrap = function(arg0) {
        const ret = ReencryptionResponse.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_require_79b1e9274cde3c87 = function() { return handleError(function () {
        const ret = module.require;
        return ret;
    }, arguments) };
    imports.wbg.__wbg_set_23d69db4e5c66a6e = function(arg0, arg1, arg2) {
        arg0.set(arg1, arg2 >>> 0);
    };
    imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {
        const ret = arg1.stack;
        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbg_static_accessor_GLOBAL_0be7472e492ad3e3 = function() {
        const ret = typeof global$1 === 'undefined' ? null : global$1;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_GLOBAL_THIS_1a6eb482d12c9bfb = function() {
        const ret = typeof globalThis === 'undefined' ? null : globalThis;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_SELF_1dc398a895c82351 = function() {
        const ret = typeof self === 'undefined' ? null : self;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_WINDOW_ae1c80c7eea8d64a = function() {
        const ret = typeof window === 'undefined' ? null : window;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_subarray_46adeb9b86949d12 = function(arg0, arg1, arg2) {
        const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);
        return ret;
    };
    imports.wbg.__wbg_typedciphertext_new = function(arg0) {
        const ret = TypedCiphertext.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_typedciphertext_unwrap = function(arg0) {
        const ret = TypedCiphertext.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_typedplaintext_new = function(arg0) {
        const ret = TypedPlaintext.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_typedsigncryptedciphertext_new = function(arg0) {
        const ret = TypedSigncryptedCiphertext.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_typedsigncryptedciphertext_unwrap = function(arg0) {
        const ret = TypedSigncryptedCiphertext.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_value_4c32fd138a88eee2 = function(arg0) {
        const ret = arg0.value;
        return ret;
    };
    imports.wbg.__wbg_versions_c71aa1626a93e0a1 = function(arg0) {
        const ret = arg0.versions;
        return ret;
    };
    imports.wbg.__wbindgen_as_number = function(arg0) {
        const ret = +arg0;
        return ret;
    };
    imports.wbg.__wbindgen_boolean_get = function(arg0) {
        const v = arg0;
        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;
        return ret;
    };
    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
        const ret = debugString(arg1);
        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
        const ret = new Error(getStringFromWasm0(arg0, arg1));
        return ret;
    };
    imports.wbg.__wbindgen_in = function(arg0, arg1) {
        const ret = arg0 in arg1;
        return ret;
    };
    imports.wbg.__wbindgen_init_externref_table = function() {
        const table = wasm.__wbindgen_export_4;
        const offset = table.grow(4);
        table.set(0, undefined);
        table.set(offset + 0, undefined);
        table.set(offset + 1, null);
        table.set(offset + 2, true);
        table.set(offset + 3, false);
    };
    imports.wbg.__wbindgen_is_function = function(arg0) {
        const ret = typeof(arg0) === 'function';
        return ret;
    };
    imports.wbg.__wbindgen_is_null = function(arg0) {
        const ret = arg0 === null;
        return ret;
    };
    imports.wbg.__wbindgen_is_object = function(arg0) {
        const val = arg0;
        const ret = typeof(val) === 'object' && val !== null;
        return ret;
    };
    imports.wbg.__wbindgen_is_string = function(arg0) {
        const ret = typeof(arg0) === 'string';
        return ret;
    };
    imports.wbg.__wbindgen_is_undefined = function(arg0) {
        const ret = arg0 === undefined;
        return ret;
    };
    imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {
        const ret = arg0 == arg1;
        return ret;
    };
    imports.wbg.__wbindgen_memory = function() {
        const ret = wasm.memory;
        return ret;
    };
    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {
        const obj = arg1;
        const ret = typeof(obj) === 'number' ? obj : undefined;
        getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
    };
    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
        const obj = arg1;
        const ret = typeof(obj) === 'string' ? obj : undefined;
        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
        const ret = getStringFromWasm0(arg0, arg1);
        return ret;
    };
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };

    return imports;
}

function __wbg_finalize_init(instance, module) {
    wasm = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedDataViewMemory0 = null;
    cachedUint8ArrayMemory0 = null;


    wasm.__wbindgen_start();
    return wasm;
}

async function __wbg_init(module_or_path) {
    if (wasm !== undefined) return wasm;


    if (typeof module_or_path !== 'undefined') {
        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
            ({module_or_path} = module_or_path);
        } else {
            console.warn('using deprecated parameters for the initialization function; pass a single object instead');
        }
    }

    if (typeof module_or_path === 'undefined') {
        module_or_path = new URL('kms_lib_bg.wasm', import.meta.url);
    }
    const imports = __wbg_get_imports();

    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {
        module_or_path = fetch(module_or_path);
    }

    const { instance, module } = await __wbg_load(await module_or_path, imports);

    return __wbg_finalize_init(instance, module);
}

const aclABI = [
    'function persistAllowed(bytes32 handle, address account) view returns (bool)',
];
const userDecryptRequest = (kmsSignatures, gatewayChainId, chainId, verifyingContractAddress, aclContractAddress, relayerUrl, provider) => async (_handles, privateKey, publicKey, signature, contractAddresses, userAddress, startTimestamp, durationDays) => {
    console.log('gatewayChainId', gatewayChainId);
    console.log('chainId', chainId);
    console.log('verifyingContractAddress', verifyingContractAddress);
    console.log('cthandles', _handles);
    // Casting handles if string
    const handles = _handles.map((h) => ({
        ctHandle: typeof h.ctHandle === 'string'
            ? toHexString(fromHexString(h.ctHandle), true)
            : toHexString(h.ctHandle, true),
        contractAddress: h.contractAddress,
    }));
    const acl = new ethers.Contract(aclContractAddress, aclABI, provider);
    const verifications = handles.map(async ({ ctHandle, contractAddress }) => {
        const userAllowed = await acl.persistAllowed(ctHandle, userAddress);
        const contractAllowed = await acl.persistAllowed(ctHandle, contractAddress);
        if (!userAllowed) {
            throw new Error('User is not authorized to reencrypt this handle!');
        }
        if (!contractAllowed) {
            throw new Error('dApp contract is not authorized to reencrypt this handle!');
        }
        if (userAddress === contractAddress) {
            throw new Error('userAddress should not be equal to contractAddress when requesting reencryption!');
        }
    });
    await Promise.all(verifications).catch((e) => {
        throw e;
    });
    const payloadForRequest = {
        HandleContractPairs: handles,
        requestValidity: {
            startTimestamp: startTimestamp.toString(), // Convert to string
            durationDays: durationDays.toString(), // Convert to string
        },
        contractsChainId: chainId.toString(), // Convert to string
        contractAddresses: contractAddresses.map((c) => getAddress(c)),
        userAddress: getAddress(userAddress),
        signature: signature.replace(/^(0x)/, ''),
        publicKey: publicKey.replace(/^(0x)/, ''),
    };
    const options = {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payloadForRequest),
    };
    let pubKey;
    let privKey;
    try {
        pubKey = u8vec_to_cryptobox_pk(fromHexString(publicKey));
        privKey = u8vec_to_cryptobox_sk(fromHexString(privateKey));
    }
    catch (e) {
        throw new Error('Invalid public or private key', { cause: e });
    }
    let response;
    let json;
    try {
        response = await fetch(`${relayerUrl}v1/user-decrypt`, options);
        if (!response.ok) {
            throw new Error(`Reencrypt failed: relayer respond with HTTP code ${response.status}`);
        }
    }
    catch (e) {
        throw new Error("Reencrypt failed: Relayer didn't respond", { cause: e });
    }
    try {
        json = await response.json();
    }
    catch (e) {
        throw new Error("Reencrypt failed: Relayer didn't return a JSON", {
            cause: e,
        });
    }
    if (json.status === 'failure') {
        throw new Error("Reencrypt failed: the reencryption didn't succeed for an unknown reason", { cause: json });
    }
    const client = new_client(kmsSignatures, userAddress, 'default');
    try {
        const buffer = new ArrayBuffer(32);
        const view = new DataView(buffer);
        view.setUint32(28, gatewayChainId, false);
        const chainIdArrayBE = new Uint8Array(buffer);
        const eip712Domain = {
            name: 'DecryptionManager',
            version: '1',
            chain_id: chainIdArrayBE,
            verifying_contract: verifyingContractAddress,
            salt: null,
        };
        // Duplicate payloadForRequest and replace ciphertext_handle with ciphertext_digest.
        // TODO check all ciphertext digests are all the same
        const payloadForVerification = {
            signature,
            client_address: userAddress,
            enc_key: publicKey.replace(/^0x/, ''),
            ciphertext_handles: handles.map((h) => h.ctHandle.replace(/^0x/, '')),
            eip712_verifying_contract: verifyingContractAddress,
        };
        console.log(payloadForVerification);
        const decryption = process_reencryption_resp_from_js(client, payloadForVerification, eip712Domain, json.response, pubKey, privKey, true);
        return decryption.map((d) => bytesToBigInt(d.bytes));
    }
    catch (e) {
        throw new Error('An error occured during decryption', { cause: e });
    }
};

const checkEncryptedValue = (value, bits) => {
    if (value == null)
        throw new Error('Missing value');
    let limit;
    if (bits >= 8) {
        limit = BigInt(`0x${new Array(bits / 8).fill(null).reduce((v) => `${v}ff`, '')}`);
    }
    else {
        limit = BigInt(2 ** bits - 1);
    }
    if (typeof value !== 'number' && typeof value !== 'bigint')
        throw new Error('Value must be a number or a bigint.');
    if (value > limit) {
        throw new Error(`The value exceeds the limit for ${bits}bits integer (${limit.toString()}).`);
    }
};
const createEncryptedInput = ({ aclContractAddress, chainId, tfheCompactPublicKey, publicParams, contractAddress, userAddress, }) => {
    if (!isAddress(contractAddress)) {
        throw new Error('Contract address is not a valid address.');
    }
    if (!isAddress(userAddress)) {
        throw new Error('User address is not a valid address.');
    }
    const publicKey = tfheCompactPublicKey;
    const bits = [];
    const builder = CompactCiphertextList.builder(publicKey);
    let ciphertextWithZKProof = new Uint8Array(); // updated in `_prove`
    const checkLimit = (added) => {
        if (bits.reduce((acc, val) => acc + Math.max(2, val), 0) + added > 2048) {
            throw Error('Packing more than 2048 bits in a single input ciphertext is unsupported');
        }
        if (bits.length + 1 > 256)
            throw Error('Packing more than 256 variables in a single input ciphertext is unsupported');
    };
    return {
        addBool(value) {
            if (value == null)
                throw new Error('Missing value');
            if (typeof value !== 'boolean' &&
                typeof value !== 'number' &&
                typeof value !== 'bigint')
                throw new Error('The value must be a boolean, a number or a bigint.');
            if ((typeof value !== 'bigint' || typeof value !== 'number') &&
                Number(value) > 1)
                throw new Error('The value must be 1 or 0.');
            checkEncryptedValue(Number(value), 1);
            checkLimit(2);
            builder.push_boolean(!!value);
            bits.push(1); // ebool takes 2 encrypted bits
            return this;
        },
        add8(value) {
            checkEncryptedValue(value, 8);
            checkLimit(8);
            builder.push_u8(Number(value));
            bits.push(8);
            return this;
        },
        add16(value) {
            checkEncryptedValue(value, 16);
            checkLimit(16);
            builder.push_u16(Number(value));
            bits.push(16);
            return this;
        },
        add32(value) {
            checkEncryptedValue(value, 32);
            checkLimit(32);
            builder.push_u32(Number(value));
            bits.push(32);
            return this;
        },
        add64(value) {
            checkEncryptedValue(value, 64);
            checkLimit(64);
            builder.push_u64(BigInt(value));
            bits.push(64);
            return this;
        },
        add128(value) {
            checkEncryptedValue(value, 128);
            checkLimit(128);
            builder.push_u128(BigInt(value));
            bits.push(128);
            return this;
        },
        addAddress(value) {
            if (!isAddress(value)) {
                throw new Error('The value must be a valid address.');
            }
            checkLimit(160);
            builder.push_u160(BigInt(value));
            bits.push(160);
            return this;
        },
        add256(value) {
            checkEncryptedValue(value, 256);
            checkLimit(256);
            builder.push_u256(BigInt(value));
            bits.push(256);
            return this;
        },
        addBytes64(value) {
            if (value.length !== 64)
                throw Error('Uncorrect length of input Uint8Array, should be 64 for an ebytes64');
            const bigIntValue = bytesToBigInt(value);
            checkEncryptedValue(bigIntValue, 512);
            checkLimit(512);
            builder.push_u512(bigIntValue);
            bits.push(512);
            return this;
        },
        addBytes128(value) {
            if (value.length !== 128)
                throw Error('Uncorrect length of input Uint8Array, should be 128 for an ebytes128');
            const bigIntValue = bytesToBigInt(value);
            checkEncryptedValue(bigIntValue, 1024);
            checkLimit(1024);
            builder.push_u1024(bigIntValue);
            bits.push(1024);
            return this;
        },
        addBytes256(value) {
            if (value.length !== 256)
                throw Error('Uncorrect length of input Uint8Array, should be 256 for an ebytes256');
            const bigIntValue = bytesToBigInt(value);
            checkEncryptedValue(bigIntValue, 2048);
            checkLimit(2048);
            builder.push_u2048(bigIntValue);
            bits.push(2048);
            return this;
        },
        getBits() {
            return bits;
        },
        encrypt() {
            const getClosestPP = () => {
                const getKeys = (obj) => Object.keys(obj);
                const totalBits = bits.reduce((total, v) => total + v, 0);
                const ppTypes = getKeys(publicParams);
                const closestPP = ppTypes.find((k) => Number(k) >= totalBits);
                if (!closestPP) {
                    throw new Error(`Too many bits in provided values. Maximum is ${ppTypes[ppTypes.length - 1]}.`);
                }
                return closestPP;
            };
            const closestPP = getClosestPP();
            const pp = publicParams[closestPP].publicParams;
            const buffContract = fromHexString(contractAddress);
            const buffUser = fromHexString(userAddress);
            const buffAcl = fromHexString(aclContractAddress);
            const buffChainId = fromHexString(chainId.toString(16));
            const auxData = new Uint8Array(buffContract.length + buffUser.length + buffAcl.length + 32);
            auxData.set(buffContract, 0);
            auxData.set(buffUser, 20);
            auxData.set(buffAcl, 40);
            auxData.set(buffChainId, auxData.length - buffChainId.length);
            const encrypted = builder.build_with_proof_packed(pp, auxData, ZkComputeLoad.Verify);
            ciphertextWithZKProof = encrypted.safe_serialize(SERIALIZED_SIZE_LIMIT_CIPHERTEXT);
            return ciphertextWithZKProof;
        },
    };
};

const ENCRYPTION_TYPES = {
    1: 0, // ebool takes 2 encrypted bits
    8: 2,
    16: 3,
    32: 4,
    64: 5,
    128: 6,
    160: 7,
    256: 8,
    512: 9,
    1024: 10,
    2048: 11,
};

const MAX_UINT64 = BigInt('18446744073709551615'); // 2^64 - 1
const computeHandles = (ciphertextWithZKProof, bitwidths, aclContractAddress, chainId, ciphertextVersion) => {
    // Should be identical to:
    // https://github.com/zama-ai/fhevm-backend/blob/bae00d1b0feafb63286e94acdc58dc88d9c481bf/fhevm-engine/zkproof-worker/src/verifier.rs#L301
    const blob_hash = createHash('keccak256')
        .update(Buffer.from(ciphertextWithZKProof))
        .digest();
    const aclContractAddress20Bytes = Buffer.from(fromHexString(aclContractAddress));
    const chainId32Bytes = Buffer.from(new Uint8Array(toBufferBE(BigInt(chainId), 32)));
    const handles = bitwidths.map((bitwidth, encryptionIndex) => {
        const encryptionType = ENCRYPTION_TYPES[bitwidth];
        const encryptionIndex1Byte = Buffer.from([encryptionIndex]);
        const handleHash = createHash('keccak256')
            .update(blob_hash)
            .update(encryptionIndex1Byte)
            .update(aclContractAddress20Bytes)
            .update(chainId32Bytes)
            .digest();
        const dataInput = new Uint8Array(32);
        dataInput.set(handleHash, 0);
        // Check if chainId exceeds 8 bytes
        if (BigInt(chainId) > MAX_UINT64) {
            throw new Error('ChainId exceeds maximum allowed value (8 bytes)'); // fhevm assumes chainID is only taking up to 8 bytes
        }
        const chainId8Bytes = chainId32Bytes.slice(24, 32);
        dataInput[21] = encryptionIndex;
        chainId8Bytes.copy(dataInput, 22);
        dataInput[30] = encryptionType;
        dataInput[31] = ciphertextVersion;
        return dataInput;
    });
    return handles;
};

const currentCiphertextVersion = () => {
    return 0;
};
const createRelayerEncryptedInput = (aclContractAddress, chainId, relayerUrl, tfheCompactPublicKey, publicParams) => (contractAddress, userAddress) => {
    if (!isAddress(contractAddress)) {
        throw new Error('Contract address is not a valid address.');
    }
    if (!isAddress(userAddress)) {
        throw new Error('User address is not a valid address.');
    }
    const input = createEncryptedInput({
        aclContractAddress,
        chainId,
        tfheCompactPublicKey,
        publicParams,
        contractAddress,
        userAddress,
    });
    return {
        ...input,
        _input: input,
        encrypt: async () => {
            const bits = input.getBits();
            const ciphertext = input.encrypt();
            // https://github.com/zama-ai/fhevm-relayer/blob/978b08f62de060a9b50d2c6cc19fd71b5fb8d873/src/input_http_listener.rs#L13C1-L22C1
            const payload = {
                contractAddress: getAddress(contractAddress),
                userAddress: getAddress(userAddress),
                ciphertextWithZkpok: toHexString(ciphertext),
                contractChainId: '0x' + chainId.toString(16),
            };
            const options = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            };
            const url = `${relayerUrl}/v1/input-proof`;
            let json;
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(`Relayer didn't response correctly. Bad status ${response.statusText}. Content: ${await response.text()}`);
                }
                try {
                    json = await response.json();
                }
                catch (e) {
                    throw new Error("Relayer didn't response correctly. Bad JSON.", {
                        cause: e,
                    });
                }
            }
            catch (e) {
                throw new Error("Relayer didn't response correctly.", {
                    cause: e,
                });
            }
            const handles = computeHandles(ciphertext, bits, aclContractAddress, chainId, currentCiphertextVersion());
            // Note that the hex strings returned by the relayer do have have the 0x prefix
            if (json.response.handles && json.response.handles.length > 0) {
                const responseHandles = json.response.handles.map(fromHexString);
                if (handles.length != responseHandles.length) {
                    throw new Error(`Incorrect Handles list sizes: (expected) ${handles.length} != ${responseHandles.length} (received)`);
                }
                for (let index = 0; index < handles.length; index += 1) {
                    let handle = handles[index];
                    let responseHandle = responseHandles[index];
                    let expected = toHexString(handle);
                    let current = toHexString(responseHandle);
                    if (expected !== current) {
                        throw new Error(`Incorrect Handle ${index}: (expected) ${expected} != ${current} (received)`);
                    }
                }
            }
            const signatures = json.response.signatures;
            // inputProof is len(list_handles) + numCoprocessorSigners + list_handles + signatureCoprocessorSigners (1+1+NUM_HANDLES*32+65*numSigners)
            let inputProof = numberToHex(handles.length);
            const numSigners = signatures.length;
            inputProof += numberToHex(numSigners);
            const listHandlesStr = handles.map((i) => toHexString(i));
            listHandlesStr.map((handle) => (inputProof += handle));
            signatures.map((signature) => (inputProof += signature.slice(2))); // removes the '0x' prefix from the `signature` string
            return {
                handles,
                inputProof: fromHexString(inputProof),
            };
        },
    };
};

const publicDecryptRequest = (kmsSignatures, gatewayChainId, chainId, verifyingContractAddress, aclContractAddress, relayerUrl, provider) => async (_handle) => {
    const handle = typeof _handle === 'string'
        ? toHexString(fromHexString(_handle), true)
        : toHexString(_handle, true);
    const payloadForRequest = {
        ciphertext_handle: handle,
    };
    const options = {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payloadForRequest),
    };
    let response;
    let json;
    try {
        response = await fetch(`${relayerUrl}v1/public-decrypt`, options);
        if (!response.ok) {
            throw new Error(`Reencrypt failed: relayer respond with HTTP code ${response.status}`);
        }
    }
    catch (e) {
        throw new Error("Public decrypt failed: Relayer didn't respond", {
            cause: e,
        });
    }
    try {
        json = await response.json();
    }
    catch (e) {
        throw new Error("Public decrypt failed: Relayer didn't return a JSON", {
            cause: e,
        });
    }
    if (json.status === 'failure') {
        throw new Error("Public decrypt failed: the public decrypt didn't succeed for an unknown reason", { cause: json });
    }
    // TODO verify signature on decryption
    return json;
};

/**
 * Creates an EIP712 structure specifically for user decrypt requests
 *
 * @param gatewayChainId The chain ID of the gateway
 * @param verifyingContract The address of the contract that will verify the signature
 * @param publicKey The user's public key as a hex string or Uint8Array
 * @param contractAddresses Array of contract addresses that can access the decryption
 * @param contractsChainId The chain ID where the contracts are deployed
 * @param startTimestamp The timestamp when the decryption permission becomes valid
 * @param durationDays How many days the decryption permission remains valid
 * @returns EIP712 typed data structure for user decryption
 */
const createEIP712 = (gatewayChainId, verifyingContract, contractsChainId) => (publicKey, contractAddresses, startTimestamp, durationDays, delegatedAccount) => {
    if (delegatedAccount && !isAddress(delegatedAccount))
        throw new Error('Invalid delegated account.');
    if (!isAddress(verifyingContract)) {
        throw new Error('Invalid verifying contract address.');
    }
    if (!contractAddresses.every((c) => isAddress(c))) {
        throw new Error('Invalid contract address.');
    }
    // Format the public key based on its type
    const formattedPublicKey = typeof publicKey === 'string'
        ? publicKey.startsWith('0x')
            ? publicKey
            : `0x${publicKey}`
        : publicKey;
    // Convert timestamps to strings if they're bigints
    const formattedStartTimestamp = typeof startTimestamp === 'number'
        ? startTimestamp.toString()
        : startTimestamp;
    const formattedDurationDays = typeof durationDays === 'number' ? durationDays.toString() : durationDays;
    const EIP712Domain = [
        { name: 'name', type: 'string' },
        { name: 'version', type: 'string' },
        { name: 'chainId', type: 'uint256' },
        { name: 'verifyingContract', type: 'address' },
    ];
    const domain = {
        name: 'DecryptionManager',
        version: '1',
        chainId: gatewayChainId,
        verifyingContract,
    };
    if (delegatedAccount) {
        return {
            types: {
                EIP712Domain,
                DelegatedUserDecryptRequestVerification: [
                    { name: 'publicKey', type: 'bytes' },
                    { name: 'contractAddresses', type: 'address[]' },
                    { name: 'contractsChainId', type: 'uint256' },
                    { name: 'startTimestamp', type: 'uint256' },
                    { name: 'durationDays', type: 'uint256' },
                    {
                        name: 'delegatedAccount',
                        type: 'address',
                    },
                ],
            },
            primaryType: 'DelegatedUserDecryptRequestVerification',
            domain,
            message: {
                publicKey: formattedPublicKey,
                contractAddresses,
                contractsChainId,
                startTimestamp: formattedStartTimestamp,
                durationDays: formattedDurationDays,
                delegatedAccount: delegatedAccount,
            },
        };
    }
    return {
        types: {
            EIP712Domain,
            UserDecryptRequestVerification: [
                { name: 'publicKey', type: 'bytes' },
                { name: 'contractAddresses', type: 'address[]' },
                { name: 'contractsChainId', type: 'uint256' },
                { name: 'startTimestamp', type: 'uint256' },
                { name: 'durationDays', type: 'uint256' },
            ],
        },
        primaryType: 'UserDecryptRequestVerification',
        domain,
        message: {
            publicKey: formattedPublicKey,
            contractAddresses,
            contractsChainId,
            startTimestamp: formattedStartTimestamp,
            durationDays: formattedDurationDays,
        },
    };
};
const generateKeypair = () => {
    const keypair = cryptobox_keygen();
    return {
        publicKey: toHexString(cryptobox_pk_to_u8vec(cryptobox_get_pk(keypair))),
        privateKey: toHexString(cryptobox_sk_to_u8vec(keypair)),
    };
};

global.fetch = fetchRetry(global.fetch, { retries: 5, retryDelay: 500 });
const createInstance = async (config) => {
    const { publicKey, kmsContractAddress, verifyingContractAddress, aclContractAddress, gatewayChainId, } = config;
    if (!kmsContractAddress || !isAddress(kmsContractAddress)) {
        throw new Error('KMS contract address is not valid or empty');
    }
    if (!verifyingContractAddress || !isAddress(verifyingContractAddress)) {
        throw new Error('Verifying contract address is not valid or empty');
    }
    if (!aclContractAddress || !isAddress(aclContractAddress)) {
        throw new Error('ACL contract address is not valid or empty');
    }
    if (publicKey && !(publicKey.data instanceof Uint8Array))
        throw new Error('publicKey must be a Uint8Array');
    const provider = getProvider(config);
    if (!provider) {
        throw new Error('No network has been provided!');
    }
    const chainId = await getChainId(provider, config);
    const publicKeyData = await getTfheCompactPublicKey(config);
    const publicParamsData = await getPublicParams(config);
    const kmsSigners = await getKMSSigners(provider, config);
    return {
        createEncryptedInput: createRelayerEncryptedInput(aclContractAddress, chainId, cleanURL(config.relayerUrl), publicKeyData.publicKey, publicParamsData),
        generateKeypair,
        createEIP712: createEIP712(gatewayChainId, verifyingContractAddress, chainId),
        publicDecrypt: publicDecryptRequest(kmsSigners, gatewayChainId, chainId, verifyingContractAddress, aclContractAddress, cleanURL(config.relayerUrl)),
        userDecrypt: userDecryptRequest(kmsSigners, gatewayChainId, chainId, verifyingContractAddress, aclContractAddress, cleanURL(config.relayerUrl), provider),
        getPublicKey: () => publicKeyData.publicKey
            ? {
                publicKey: publicKeyData.publicKey.safe_serialize(SERIALIZED_SIZE_LIMIT_PK),
                publicKeyId: publicKeyData.publicKeyId,
            }
            : null,
        getPublicParams: (bits) => {
            if (publicParamsData[bits]) {
                return {
                    publicParams: publicParamsData[bits].publicParams.safe_serialize(SERIALIZED_SIZE_LIMIT_CRS),
                    publicParamsId: publicParamsData[bits].publicParamsId,
                };
            }
            return null;
        },
    };
};

let initialized = false;
const initFhevm = async ({ tfheParams, kmsParams, thread, } = {}) => {
    if (thread == null)
        thread = navigator.hardwareConcurrency;
    let supportsThreads = await threads();
    if (!supportsThreads) {
        console.warn('This browser does not support threads. Verify that your server returns correct headers:\n', "'Cross-Origin-Opener-Policy': 'same-origin'\n", "'Cross-Origin-Embedder-Policy': 'require-corp'");
        thread = undefined;
    }
    if (!initialized) {
        await __wbg_init$1({ module_or_path: tfheParams });
        await __wbg_init({
            module_or_path: kmsParams,
        });
        if (thread) {
            init_panic_hook();
            await initThreadPool(thread);
        }
        initialized = true;
    }
    return true;
};

export { createEIP712, createInstance, generateKeypair, initFhevm };
